{"version":3,"sources":["../src/ai-sdk.ts","../src/core/utils/stream/merge.ts","../src/core/modules/text.ts","../src/core/modules/tool-call.ts","../src/core/utils/Counter.ts","../src/core/utils/stream/path-utils.ts","../src/core/utils/generateId.tsx","../src/core/modules/assistant-stream.ts","../src/core/utils/stream/AssistantTransformStream.ts","../src/ai-sdk/index.ts","../src/ai-sdk/language-model.ts"],"sourcesContent":["export * from \"./ai-sdk/index\";\nexport { LanguageModelV1StreamDecoder } from \"./ai-sdk/language-model\";\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\n\ntype MergeStreamItem = {\n  reader: ReadableStreamDefaultReader<AssistantStreamChunk>;\n  promise?: Promise<unknown> | undefined;\n};\n\nconst promiseWithResolvers = () => {\n  let resolve: () => void;\n  let reject: (reason?: any) => void;\n  const promise = new Promise<void>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve: resolve!, reject: reject! };\n};\n\nexport const createMergeStream = () => {\n  const list: MergeStreamItem[] = [];\n  let sealed = false;\n  let controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  let currentPull: ReturnType<typeof promiseWithResolvers> | undefined;\n\n  const handlePull = (item: MergeStreamItem) => {\n    if (!item.promise) {\n      // TODO for most streams, we can directly pipeTo to avoid the microTask queue\n      // add an option to eagerly pipe the stream to the merge stream\n      // ideally, using assitant-stream w sync run method + piping to a sync WritableStream runs in the same microtask\n      // this is useful because we often use AssistantStreams internally as a serialization utility, e. g. AssistantTransformStream\n      // idea: avoid reader.read() by instead using a WritableStream & if (!hasPendingPull) await waitForPull()?\n      item.promise = item.reader\n        .read()\n        .then(({ done, value }) => {\n          item.promise = undefined;\n          if (done) {\n            list.splice(list.indexOf(item), 1);\n            if (sealed && list.length === 0) {\n              controller.close();\n            }\n          } else {\n            controller.enqueue(value);\n          }\n\n          currentPull?.resolve();\n          currentPull = undefined;\n        })\n        .catch((e) => {\n          console.error(e);\n\n          list.forEach((item) => {\n            item.reader.cancel();\n          });\n          list.length = 0;\n\n          controller.error(e);\n\n          currentPull?.reject(e);\n          currentPull = undefined;\n        });\n    }\n  };\n\n  const readable = new ReadableStream<AssistantStreamChunk>({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      currentPull = promiseWithResolvers();\n      list.forEach((item) => {\n        handlePull(item);\n      });\n\n      return currentPull.promise;\n    },\n    cancel() {\n      list.forEach((item) => {\n        item.reader.cancel();\n      });\n      list.length = 0;\n    },\n  });\n\n  return {\n    readable,\n    isSealed() {\n      return sealed;\n    },\n    seal() {\n      sealed = true;\n      if (list.length === 0) controller.close();\n    },\n    addStream(stream: ReadableStream<AssistantStreamChunk>) {\n      if (sealed)\n        throw new Error(\n          \"Cannot add streams after the run callback has settled.\",\n        );\n\n      const item = { reader: stream.getReader() };\n      list.push(item);\n      handlePull(item);\n    },\n    enqueue(chunk: AssistantStreamChunk) {\n      this.addStream(\n        new ReadableStream({\n          start(c) {\n            c.enqueue(chunk);\n            c.close();\n          },\n        }),\n      );\n    },\n  };\n};\n\n// TODO\n// export class SpanContainerMerger {\n//   public get isSealed() {\n//     return this.mergeStream.isSealed();\n//   }\n\n//   public get readable() {\n//     return this.mergeStream.readable;\n//   }\n\n//   private subAllocator = new Counter();\n//   private mergeStream = createMergeStream();\n\n//   constructor() {\n//     // id 0 is auto allocated\n//     this.subAllocator.up();\n//   }\n\n//   add(stream: ReadableStream<AssistantStreamChunk>) {\n//     this.mergeStream.addStream(\n//       stream.pipeThrough(new SpanParentEncoder(this.subAllocator)),\n//     );\n//   }\n\n//   enqueue(chunk: AssistantStreamChunk & { parentId: 0 }) {\n//     this.mergeStream.addStream(\n//       new ReadableStream({\n//         start(c) {\n//           c.enqueue(chunk);\n//           c.close();\n//         },\n//       }),\n//     );\n//   }\n\n//   seal() {\n//     this.mergeStream.seal();\n//   }\n// }\n\n// export class SpanContainerSplitter {\n//   public writable;\n\n//   private isSealed = false;\n//   private writers = new Map<\n//     number,\n//     WritableStreamDefaultWriter<AssistantStreamChunk>\n//   >();\n\n//   private closeTasks: Promise<void>[] = [];\n\n//   private allocator = new Counter();\n//   private subAllocator = new Counter();\n\n//   constructor() {\n//     // id 0 is auto-allocated\n//     this.allocator.up();\n\n//     this.writable = new WritableStream({\n//       write: (chunk) => {\n//         const { type, parentId } = chunk;\n\n//         const writer = this.writers.get(parentId);\n//         if (writer === undefined) throw new Error(\"Parent id not found\");\n\n//         writer.write(chunk);\n\n//         if (type === \"span\") {\n//           // allocate a new span id\n//           this.writers.set(this.allocator.up(), writer);\n//         }\n//         if (type === \"finish\") {\n//           this.writers.delete(parentId);\n//           writer.close();\n\n//           if (this.writers.size === 0) {\n//             const closeTask = this.writable.close();\n//             this.closeTasks.push(closeTask);\n//             closeTask.then(() => {\n//               this.closeTasks.splice(this.closeTasks.indexOf(closeTask), 1);\n//             });\n//           }\n//         }\n//       },\n//       close: async () => {\n//         if (this.writers.size > 0) throw new Error(\"Not all writers closed\");\n\n//         // await and throw on any errors\n//         await Promise.all(this.closeTasks);\n//       },\n//     });\n//   }\n\n//   add(stream: WritableStream<AssistantStreamChunk>) {\n//     if (this.isSealed) throw new Error(\"Cannot add streams after sealing\");\n\n//     const decoder = new SpanParentDecoder(this.subAllocator);\n//     decoder.readable.pipeTo(stream);\n\n//     this.writers.set(this.allocator.up(), decoder.writable.getWriter());\n//   }\n\n//   seal() {\n//     this.isSealed = true;\n//     if (this.writers.size === 0) this.writable.close();\n//   }\n// }\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\n\nexport type TextStreamController = {\n  append(textDelta: string): void;\n  close(): void; // TODO reason? error?\n};\n\nclass TextStreamControllerImpl implements TextStreamController {\n  private _controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  private _isClosed = false;\n\n  constructor(\n    controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    this._controller = controller;\n  }\n\n  append(textDelta: string) {\n    this._controller.enqueue({\n      type: \"text-delta\",\n      path: [],\n      textDelta,\n    });\n    return this;\n  }\n\n  close() {\n    if (this._isClosed) return;\n    this._isClosed = true;\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createTextStream = (\n  readable: UnderlyingReadable<TextStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new TextStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new TextStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createTextStreamController = () => {\n  let controller!: TextStreamController;\n  const stream = createTextStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { ToolResponseInit } from \"../ToolResponse\";\nimport { ReadonlyJSONValue } from \"../utils/json/json-value\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\nimport { createTextStream, TextStreamController } from \"./text\";\n\nexport type ToolCallStreamController = {\n  argsText: TextStreamController;\n\n  setResponse(response: ToolResponseInit<ReadonlyJSONValue>): void;\n  close(): void;\n};\n\nclass ToolCallStreamControllerImpl implements ToolCallStreamController {\n  private _isClosed = false;\n\n  private _mergeTask: Promise<void>;\n  constructor(\n    private _controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    const stream = createTextStream({\n      start: (c) => {\n        this._argsTextController = c;\n      },\n    });\n    this._mergeTask = stream.pipeTo(\n      new WritableStream({\n        write: (chunk) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              this._controller.enqueue(chunk);\n              break;\n\n            case \"part-finish\":\n              this._controller.enqueue({\n                type: \"tool-call-args-text-finish\",\n                path: [],\n              });\n              break;\n\n            default:\n              throw new Error(`Unexpected chunk type: ${chunk.type}`);\n          }\n        },\n      }),\n    );\n  }\n\n  get argsText() {\n    return this._argsTextController;\n  }\n\n  private _argsTextController!: TextStreamController;\n\n  setResponse(response: ToolResponseInit<ReadonlyJSONValue>) {\n    this._controller.enqueue({\n      type: \"result\",\n      path: [],\n      artifact: response.artifact,\n      result: response.result,\n      isError: response.isError ?? false,\n    });\n  }\n\n  async close() {\n    if (this._isClosed) return;\n\n    this._isClosed = true;\n    this._argsTextController.close();\n    await this._mergeTask;\n\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createToolCallStream = (\n  readable: UnderlyingReadable<ToolCallStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new ToolCallStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new ToolCallStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createToolCallStreamController = () => {\n  let controller!: ToolCallStreamController;\n  const stream = createToolCallStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n","export class Counter {\n  public value = -1;\n\n  up() {\n    return ++this.value;\n  }\n}\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { Counter } from \"../Counter\";\n\nexport class PathAppendEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        controller.enqueue({\n          ...chunk,\n          path: [idx, ...chunk.path],\n        });\n      },\n    });\n  }\n}\n\nexport class PathAppendDecoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        const {\n          path: [idx2, ...path],\n        } = chunk;\n\n        if (idx !== idx2)\n          throw new Error(`Path mismatch: expected ${idx}, got ${idx2}`);\n\n        controller.enqueue({\n          ...chunk,\n          path,\n        });\n      },\n    });\n  }\n}\n\nexport class PathMergeEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(counter: Counter) {\n    const innerCounter = new Counter();\n    const mapping = new Map<number, number>();\n    super({\n      transform(chunk, controller) {\n        if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n          mapping.set(innerCounter.up(), counter.up());\n        }\n\n        const [idx, ...path] = chunk.path;\n        if (idx === undefined) {\n          controller.enqueue(chunk);\n          return;\n        }\n        const mappedIdx = mapping.get(idx);\n        if (mappedIdx === undefined) throw new Error(\"Path not found\");\n\n        controller.enqueue({\n          ...chunk,\n          path: [mappedIdx, ...path],\n        });\n      },\n    });\n  }\n}\n","import { customAlphabet } from \"nanoid/non-secure\";\n\nexport const generateId = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7,\n);\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk, PartInit } from \"../AssistantStreamChunk\";\nimport { createMergeStream } from \"../utils/stream/merge\";\nimport { createTextStreamController, TextStreamController } from \"./text\";\nimport {\n  createToolCallStreamController,\n  ToolCallStreamController,\n} from \"./tool-call\";\nimport { Counter } from \"../utils/Counter\";\nimport {\n  PathAppendEncoder,\n  PathMergeEncoder,\n} from \"../utils/stream/path-utils\";\nimport { DataStreamEncoder } from \"../serialization/data-stream/DataStream\";\nimport { FilePart, SourcePart } from \"../utils/types\";\nimport { generateId } from \"../utils/generateId\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../utils/json/json-value\";\nimport { ToolResponseInit } from \"../ToolResponse\";\n\ntype ToolCallPartInit = {\n  toolCallId?: string;\n  toolName: string;\n  argsText?: string;\n  args?: ReadonlyJSONObject;\n  response?: ToolResponseInit<ReadonlyJSONValue>;\n};\n\nexport type AssistantStreamController = {\n  appendText(textDelta: string): void;\n  appendReasoning(reasoningDelta: string): void;\n  appendSource(options: SourcePart): void;\n  appendFile(options: FilePart): void;\n  addTextPart(): TextStreamController;\n  addToolCallPart(options: string): ToolCallStreamController;\n  addToolCallPart(options: ToolCallPartInit): ToolCallStreamController;\n  enqueue(chunk: AssistantStreamChunk): void;\n  merge(stream: AssistantStream): void;\n  close(): void;\n};\n\nclass AssistantStreamControllerImpl implements AssistantStreamController {\n  private _merger = createMergeStream();\n  private _append:\n    | {\n        controller: TextStreamController;\n        kind: \"text\" | \"reasoning\";\n      }\n    | undefined;\n  private _contentCounter = new Counter();\n\n  get __internal_isClosed() {\n    return this._merger.isSealed();\n  }\n\n  __internal_getReadable() {\n    return this._merger.readable;\n  }\n\n  private _closeSubscriber: undefined | (() => void);\n  __internal_subscribeToClose(callback: () => void) {\n    this._closeSubscriber = callback;\n  }\n\n  private _addPart(part: PartInit, stream: AssistantStream) {\n    if (this._append) {\n      this._append.controller.close();\n      this._append = undefined;\n    }\n\n    this.enqueue({\n      type: \"part-start\",\n      part,\n      path: [],\n    });\n    this._merger.addStream(\n      stream.pipeThrough(new PathAppendEncoder(this._contentCounter.value)),\n    );\n  }\n\n  merge(stream: AssistantStream) {\n    this._merger.addStream(\n      stream.pipeThrough(new PathMergeEncoder(this._contentCounter)),\n    );\n  }\n\n  appendText(textDelta: string) {\n    if (this._append?.kind !== \"text\") {\n      this._append = {\n        kind: \"text\",\n        controller: this.addTextPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  appendReasoning(textDelta: string) {\n    if (this._append?.kind !== \"reasoning\") {\n      this._append = {\n        kind: \"reasoning\",\n        controller: this.addReasoningPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  addTextPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"text\" }, stream);\n    return controller;\n  }\n\n  addReasoningPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"reasoning\" }, stream);\n    return controller;\n  }\n\n  addToolCallPart(\n    options: string | ToolCallPartInit,\n  ): ToolCallStreamController {\n    const opt = typeof options === \"string\" ? { toolName: options } : options;\n    const toolName = opt.toolName;\n    const toolCallId = opt.toolCallId ?? generateId();\n\n    const [stream, controller] = createToolCallStreamController();\n    this._addPart({ type: \"tool-call\", toolName, toolCallId }, stream);\n\n    if (opt.argsText !== undefined) {\n      controller.argsText.append(opt.argsText);\n      controller.argsText.close();\n    }\n    if (opt.args !== undefined) {\n      controller.argsText.append(JSON.stringify(opt.args));\n      controller.argsText.close();\n    }\n    if (opt.response !== undefined) {\n      controller.setResponse(opt.response);\n    }\n\n    return controller;\n  }\n\n  appendSource(options: SourcePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  appendFile(options: FilePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  enqueue(chunk: AssistantStreamChunk) {\n    this._merger.enqueue(chunk);\n\n    if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n      this._contentCounter.up();\n    }\n  }\n\n  close() {\n    this._merger.seal();\n    this._append?.controller?.close();\n\n    this._closeSubscriber?.();\n  }\n}\n\nexport function createAssistantStream(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n): AssistantStream {\n  const controller = new AssistantStreamControllerImpl();\n\n  let promiseOrVoid: PromiseLike<void> | void;\n  try {\n    promiseOrVoid = callback(controller);\n  } catch (e) {\n    if (!controller.__internal_isClosed) {\n      controller.enqueue({\n        type: \"error\",\n        path: [],\n        error: String(e),\n      });\n      controller.close();\n    }\n    throw e;\n  }\n\n  if (promiseOrVoid instanceof Promise) {\n    const runTask = async () => {\n      try {\n        await promiseOrVoid;\n      } catch (e) {\n        if (!controller.__internal_isClosed) {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(e),\n          });\n        }\n        throw e;\n      } finally {\n        if (!controller.__internal_isClosed) {\n          controller.close();\n        }\n      }\n    };\n    runTask();\n  } else {\n    if (!controller.__internal_isClosed) {\n      controller.close();\n    }\n  }\n\n  return controller.__internal_getReadable();\n}\n\nconst promiseWithResolvers = function <T>() {\n  let resolve: ((value: T | PromiseLike<T>) => void) | undefined;\n  let reject: ((reason?: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  if (!resolve || !reject) throw new Error(\"Failed to create promise\");\n  return { promise, resolve, reject };\n};\n\nexport function createAssistantStreamController() {\n  const { resolve, promise } = promiseWithResolvers<void>();\n  let controller!: AssistantStreamController;\n  const stream = createAssistantStream((c) => {\n    controller = c;\n\n    (controller as AssistantStreamControllerImpl).__internal_subscribeToClose(\n      resolve,\n    );\n\n    return promise;\n  });\n  return [stream, controller] as const;\n}\n\nexport function createAssistantStreamResponse(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n) {\n  return AssistantStream.toResponse(\n    createAssistantStream(callback),\n    new DataStreamEncoder(),\n  );\n}\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport {\n  AssistantStreamController,\n  createAssistantStreamController,\n} from \"../../modules/assistant-stream\";\n\ntype AssistantTransformerFlushCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerStartCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerTransformCallback<I> = (\n  chunk: I,\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformer<I> = {\n  flush?: AssistantTransformerFlushCallback;\n  start?: AssistantTransformerStartCallback;\n  transform?: AssistantTransformerTransformCallback<I>;\n};\n\nexport class AssistantTransformStream<I> extends TransformStream<\n  I,\n  AssistantStreamChunk\n> {\n  constructor(\n    transformer: AssistantTransformer<I>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<AssistantStreamChunk>,\n  ) {\n    const [stream, runController] = createAssistantStreamController();\n\n    let runPipeTask: Promise<void>;\n    super(\n      {\n        start(controller) {\n          runPipeTask = stream\n            .pipeTo(\n              new WritableStream({\n                write(chunk) {\n                  controller.enqueue(chunk);\n                },\n                abort(reason?: any) {\n                  controller.error(reason);\n                },\n                close() {\n                  controller.terminate();\n                },\n              }),\n            )\n            .catch((error) => {\n              controller.error(error);\n            });\n\n          return transformer.start?.(runController);\n        },\n        transform(chunk) {\n          return transformer.transform?.(chunk, runController);\n        },\n        async flush() {\n          await transformer.flush?.(runController);\n          runController.close();\n          await runPipeTask;\n        },\n      },\n      writableStrategy,\n      readableStrategy,\n    );\n  }\n}\n","import type { TextStreamPart, ObjectStreamPart, Tool } from \"ai\";\nimport { AssistantStream } from \"../core/AssistantStream\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\nimport { ReadonlyJSONValue } from \"../core/utils/json/json-value\";\n\nexport const fromStreamText = (\n  stream: ReadableStream<TextStreamPart<Record<string, Tool>>>,\n): AssistantStream => {\n  const toolControllers = new Map<string, ToolCallStreamController>();\n  let currentToolCallArgsText: ToolCallStreamController | undefined;\n\n  const endCurrentToolCallArgsText = () => {\n    if (!currentToolCallArgsText) return;\n    currentToolCallArgsText.argsText.close();\n    currentToolCallArgsText = undefined;\n  };\n\n  const transformer = new AssistantTransformStream<\n    TextStreamPart<Record<string, Tool>>\n  >({\n    transform(chunk, controller) {\n      const { type } = chunk;\n\n      if (\n        type !== \"tool-call-delta\" &&\n        type !== \"tool-call\" &&\n        type !== \"error\" &&\n        (type as string) !== \"tool-result\"\n      ) {\n        endCurrentToolCallArgsText();\n      }\n\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          controller.appendText(textDelta);\n          break;\n        }\n        case \"reasoning\": {\n          const { textDelta } = chunk;\n          controller.appendReasoning(textDelta);\n          break;\n        }\n        case \"tool-call-streaming-start\": {\n          const { toolCallId, toolName } = chunk;\n          currentToolCallArgsText = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolControllers.set(toolCallId, currentToolCallArgsText);\n          break;\n        }\n        case \"tool-call-delta\": {\n          const { toolCallId, argsTextDelta } = chunk;\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.argsText.append(argsTextDelta);\n          break;\n        }\n        case \"tool-result\" as string: {\n          const { toolCallId, result } = chunk as unknown as {\n            toolCallId: string;\n            result: ReadonlyJSONValue;\n          };\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.setResponse({\n            result,\n          });\n          toolController.close();\n          toolControllers.delete(toolCallId);\n          break;\n        }\n        case \"tool-call\": {\n          const { toolCallId, toolName, args } = chunk;\n          const toolController = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolController.argsText.append(JSON.stringify(args));\n          toolController.argsText.close();\n          toolControllers.set(toolCallId, toolController);\n          break;\n        }\n\n        case \"step-start\":\n          controller.enqueue({\n            type: \"step-start\",\n            path: [],\n            messageId: chunk.messageId,\n          });\n          break;\n        case \"step-finish\":\n          controller.enqueue({\n            type: \"step-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            isContinued: chunk.isContinued,\n          });\n          break;\n        case \"error\":\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n\n        case \"finish\": {\n          controller.enqueue({\n            type: \"message-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n          });\n          break;\n        }\n\n        case \"source\":\n          controller.appendSource({\n            type: \"source\",\n            ...chunk.source,\n          });\n          break;\n\n        case \"file\":\n          controller.appendFile({\n            type: \"file\",\n            mimeType: chunk.mimeType,\n            data: chunk.base64,\n          });\n          break;\n\n        case \"reasoning-signature\":\n        case \"redacted-reasoning\":\n          // ignore these for now\n          break;\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n    flush() {\n      for (const toolController of toolControllers.values()) {\n        toolController.close();\n      }\n      toolControllers.clear();\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n\nexport const fromStreamObject = (\n  stream: ReadableStream<ObjectStreamPart<unknown>>,\n  toolName: string,\n): AssistantStream => {\n  let toolCall!: ToolCallStreamController;\n  const transformer = new AssistantTransformStream<ObjectStreamPart<unknown>>({\n    start(controller) {\n      toolCall = controller.addToolCallPart(toolName);\n    },\n    transform(chunk, controller) {\n      const { type } = chunk;\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          toolCall.argsText.append(textDelta);\n          break;\n        }\n        case \"finish\": {\n          toolCall.argsText.close();\n          toolCall.setResponse({\n            result: \"{}\",\n          });\n          break;\n        }\n\n        case \"object\":\n          break;\n\n        case \"error\": {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n        }\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n","import type { LanguageModelV1StreamPart } from \"ai\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\n\nfunction bufferToBase64(buffer: Uint8Array) {\n  return btoa(String.fromCharCode(...buffer));\n}\n\nexport class LanguageModelV1StreamDecoder extends AssistantTransformStream<LanguageModelV1StreamPart> {\n  constructor() {\n    let currentToolCall:\n      | { toolCallId: string; controller: ToolCallStreamController }\n      | undefined;\n\n    const endCurrentToolCall = () => {\n      if (!currentToolCall) return;\n      currentToolCall.controller.argsText.close();\n      currentToolCall.controller.close();\n      currentToolCall = undefined;\n    };\n\n    super({\n      transform(chunk, controller) {\n        const { type } = chunk;\n        if (\n          type === \"text-delta\" ||\n          type === \"reasoning\" ||\n          type === \"tool-call\"\n        ) {\n          endCurrentToolCall();\n        }\n\n        switch (type) {\n          case \"text-delta\": {\n            controller.appendText(chunk.textDelta);\n            break;\n          }\n          case \"reasoning\": {\n            controller.appendReasoning(chunk.textDelta);\n            break;\n          }\n\n          case \"source\": {\n            controller.appendSource({\n              type: \"source\",\n              ...chunk.source,\n            });\n            break;\n          }\n\n          case \"file\": {\n            controller.appendFile({\n              type: \"file\",\n              mimeType: chunk.mimeType,\n              data:\n                typeof chunk.data === \"string\"\n                  ? chunk.data\n                  : bufferToBase64(chunk.data),\n            });\n            break;\n          }\n\n          case \"tool-call-delta\": {\n            const { toolCallId, toolName, argsTextDelta } = chunk;\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            } else {\n              endCurrentToolCall();\n              currentToolCall = {\n                toolCallId,\n                controller: controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                }),\n              };\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            }\n\n            break;\n          }\n\n          case \"tool-call\": {\n            const { toolCallId, toolName, args } = chunk;\n\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.close();\n            } else {\n              const toolController = controller.addToolCallPart({\n                toolCallId,\n                toolName,\n                argsText: args,\n              });\n              toolController.close();\n            }\n            \n            break;\n          }\n          case \"finish\": {\n            controller.enqueue({\n              type: \"message-finish\",\n              finishReason: chunk.finishReason,\n              usage: chunk.usage,\n              path: [],\n            });\n            controller.close();\n            break;\n          }\n\n          case \"error\":\n          case \"response-metadata\":\n          case \"reasoning-signature\":\n          case \"redacted-reasoning\":\n            break;\n\n          default: {\n            const unhandledType: never = type;\n            throw new Error(`Unhandled chunk type: ${unhandledType}`);\n          }\n        }\n      },\n      flush() {\n        endCurrentToolCall();\n      },\n    });\n  }\n}\n"],"mappings":"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","names":["item","promiseWithResolvers"]}