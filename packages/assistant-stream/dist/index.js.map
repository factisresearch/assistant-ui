{"version":3,"sources":["../src/index.ts","../src/core/AssistantStream.ts","../src/core/utils/stream/merge.ts","../src/core/modules/text.ts","../src/core/modules/tool-call.ts","../src/core/utils/Counter.ts","../src/core/utils/stream/path-utils.ts","../src/core/utils/stream/AssistantTransformStream.ts","../src/core/utils/stream/PipeableTransformStream.ts","../src/core/utils/stream/LineDecoderStream.ts","../src/core/serialization/data-stream/serialization.ts","../src/core/utils/stream/AssistantMetaTransformStream.ts","../src/core/serialization/data-stream/DataStream.ts","../src/core/utils/generateId.tsx","../src/core/modules/assistant-stream.ts","../src/core/effects/ToolExecutionStream.ts","../src/core/utils/withPromiseOrValue.ts","../src/core/utils/json/parse-partial-json.ts","../src/core/utils/json/fix-json.ts","../src/core/accumulators/assistant-message-accumulator.ts","../src/core/serialization/PlainText.ts","../src/core/accumulators/AssistantMessageStream.ts","../src/core/ToolResponse.ts"],"sourcesContent":["export * from \"./core\";\n","import { AssistantStreamChunk } from \"./AssistantStreamChunk\";\n\nexport type AssistantStream = ReadableStream<AssistantStreamChunk>;\n\nexport type AssistantStreamEncoder = ReadableWritablePair<\n  Uint8Array,\n  AssistantStreamChunk\n> & {\n  headers?: Headers;\n};\n\nexport const AssistantStream = {\n  toResponse(stream: AssistantStream, transformer: AssistantStreamEncoder) {\n    return new Response(AssistantStream.toByteStream(stream, transformer), {\n      headers: transformer.headers ?? {},\n    });\n  },\n\n  fromResponse(\n    response: Response,\n    transformer: ReadableWritablePair<AssistantStreamChunk, Uint8Array>,\n  ) {\n    return AssistantStream.fromByteStream(response.body!, transformer);\n  },\n\n  toByteStream(\n    stream: AssistantStream,\n    transformer: ReadableWritablePair<Uint8Array, AssistantStreamChunk>,\n  ) {\n    return stream.pipeThrough(transformer);\n  },\n\n  fromByteStream(\n    readable: ReadableStream<Uint8Array>,\n    transformer: ReadableWritablePair<AssistantStreamChunk, Uint8Array>,\n  ) {\n    return readable.pipeThrough(transformer);\n  },\n};\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\n\ntype MergeStreamItem = {\n  reader: ReadableStreamDefaultReader<AssistantStreamChunk>;\n  promise?: Promise<unknown> | undefined;\n};\n\nconst promiseWithResolvers = () => {\n  let resolve: () => void;\n  let reject: (reason?: any) => void;\n  const promise = new Promise<void>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve: resolve!, reject: reject! };\n};\n\nexport const createMergeStream = () => {\n  const list: MergeStreamItem[] = [];\n  let sealed = false;\n  let controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  let currentPull: ReturnType<typeof promiseWithResolvers> | undefined;\n\n  const handlePull = (item: MergeStreamItem) => {\n    if (!item.promise) {\n      // TODO for most streams, we can directly pipeTo to avoid the microTask queue\n      // add an option to eagerly pipe the stream to the merge stream\n      // ideally, using assitant-stream w sync run method + piping to a sync WritableStream runs in the same microtask\n      // this is useful because we often use AssistantStreams internally as a serialization utility, e. g. AssistantTransformStream\n      // idea: avoid reader.read() by instead using a WritableStream & if (!hasPendingPull) await waitForPull()?\n      item.promise = item.reader\n        .read()\n        .then(({ done, value }) => {\n          item.promise = undefined;\n          if (done) {\n            list.splice(list.indexOf(item), 1);\n            if (sealed && list.length === 0) {\n              controller.close();\n            }\n          } else {\n            controller.enqueue(value);\n          }\n\n          currentPull?.resolve();\n          currentPull = undefined;\n        })\n        .catch((e) => {\n          console.error(e);\n\n          list.forEach((item) => {\n            item.reader.cancel();\n          });\n          list.length = 0;\n\n          controller.error(e);\n\n          currentPull?.reject(e);\n          currentPull = undefined;\n        });\n    }\n  };\n\n  const readable = new ReadableStream<AssistantStreamChunk>({\n    start(c) {\n      controller = c;\n    },\n    pull() {\n      currentPull = promiseWithResolvers();\n      list.forEach((item) => {\n        handlePull(item);\n      });\n\n      return currentPull.promise;\n    },\n    cancel() {\n      list.forEach((item) => {\n        item.reader.cancel();\n      });\n      list.length = 0;\n    },\n  });\n\n  return {\n    readable,\n    isSealed() {\n      return sealed;\n    },\n    seal() {\n      sealed = true;\n      if (list.length === 0) controller.close();\n    },\n    addStream(stream: ReadableStream<AssistantStreamChunk>) {\n      if (sealed)\n        throw new Error(\n          \"Cannot add streams after the run callback has settled.\",\n        );\n\n      const item = { reader: stream.getReader() };\n      list.push(item);\n      handlePull(item);\n    },\n    enqueue(chunk: AssistantStreamChunk) {\n      this.addStream(\n        new ReadableStream({\n          start(c) {\n            c.enqueue(chunk);\n            c.close();\n          },\n        }),\n      );\n    },\n  };\n};\n\n// TODO\n// export class SpanContainerMerger {\n//   public get isSealed() {\n//     return this.mergeStream.isSealed();\n//   }\n\n//   public get readable() {\n//     return this.mergeStream.readable;\n//   }\n\n//   private subAllocator = new Counter();\n//   private mergeStream = createMergeStream();\n\n//   constructor() {\n//     // id 0 is auto allocated\n//     this.subAllocator.up();\n//   }\n\n//   add(stream: ReadableStream<AssistantStreamChunk>) {\n//     this.mergeStream.addStream(\n//       stream.pipeThrough(new SpanParentEncoder(this.subAllocator)),\n//     );\n//   }\n\n//   enqueue(chunk: AssistantStreamChunk & { parentId: 0 }) {\n//     this.mergeStream.addStream(\n//       new ReadableStream({\n//         start(c) {\n//           c.enqueue(chunk);\n//           c.close();\n//         },\n//       }),\n//     );\n//   }\n\n//   seal() {\n//     this.mergeStream.seal();\n//   }\n// }\n\n// export class SpanContainerSplitter {\n//   public writable;\n\n//   private isSealed = false;\n//   private writers = new Map<\n//     number,\n//     WritableStreamDefaultWriter<AssistantStreamChunk>\n//   >();\n\n//   private closeTasks: Promise<void>[] = [];\n\n//   private allocator = new Counter();\n//   private subAllocator = new Counter();\n\n//   constructor() {\n//     // id 0 is auto-allocated\n//     this.allocator.up();\n\n//     this.writable = new WritableStream({\n//       write: (chunk) => {\n//         const { type, parentId } = chunk;\n\n//         const writer = this.writers.get(parentId);\n//         if (writer === undefined) throw new Error(\"Parent id not found\");\n\n//         writer.write(chunk);\n\n//         if (type === \"span\") {\n//           // allocate a new span id\n//           this.writers.set(this.allocator.up(), writer);\n//         }\n//         if (type === \"finish\") {\n//           this.writers.delete(parentId);\n//           writer.close();\n\n//           if (this.writers.size === 0) {\n//             const closeTask = this.writable.close();\n//             this.closeTasks.push(closeTask);\n//             closeTask.then(() => {\n//               this.closeTasks.splice(this.closeTasks.indexOf(closeTask), 1);\n//             });\n//           }\n//         }\n//       },\n//       close: async () => {\n//         if (this.writers.size > 0) throw new Error(\"Not all writers closed\");\n\n//         // await and throw on any errors\n//         await Promise.all(this.closeTasks);\n//       },\n//     });\n//   }\n\n//   add(stream: WritableStream<AssistantStreamChunk>) {\n//     if (this.isSealed) throw new Error(\"Cannot add streams after sealing\");\n\n//     const decoder = new SpanParentDecoder(this.subAllocator);\n//     decoder.readable.pipeTo(stream);\n\n//     this.writers.set(this.allocator.up(), decoder.writable.getWriter());\n//   }\n\n//   seal() {\n//     this.isSealed = true;\n//     if (this.writers.size === 0) this.writable.close();\n//   }\n// }\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\n\nexport type TextStreamController = {\n  append(textDelta: string): void;\n  close(): void; // TODO reason? error?\n};\n\nclass TextStreamControllerImpl implements TextStreamController {\n  private _controller: ReadableStreamDefaultController<AssistantStreamChunk>;\n  private _isClosed = false;\n\n  constructor(\n    controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    this._controller = controller;\n  }\n\n  append(textDelta: string) {\n    this._controller.enqueue({\n      type: \"text-delta\",\n      path: [],\n      textDelta,\n    });\n    return this;\n  }\n\n  close() {\n    if (this._isClosed) return;\n    this._isClosed = true;\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createTextStream = (\n  readable: UnderlyingReadable<TextStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new TextStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new TextStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createTextStreamController = () => {\n  let controller!: TextStreamController;\n  const stream = createTextStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { ToolResponseInit } from \"../ToolResponse\";\nimport { ReadonlyJSONValue } from \"../utils/json/json-value\";\nimport { UnderlyingReadable } from \"../utils/stream/UnderlyingReadable\";\nimport { createTextStream, TextStreamController } from \"./text\";\n\nexport type ToolCallStreamController = {\n  argsText: TextStreamController;\n\n  setResponse(response: ToolResponseInit<ReadonlyJSONValue>): void;\n  close(): void;\n};\n\nclass ToolCallStreamControllerImpl implements ToolCallStreamController {\n  private _isClosed = false;\n\n  private _mergeTask: Promise<void>;\n  constructor(\n    private _controller: ReadableStreamDefaultController<AssistantStreamChunk>,\n  ) {\n    const stream = createTextStream({\n      start: (c) => {\n        this._argsTextController = c;\n      },\n    });\n    this._mergeTask = stream.pipeTo(\n      new WritableStream({\n        write: (chunk) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              this._controller.enqueue(chunk);\n              break;\n\n            case \"part-finish\":\n              this._controller.enqueue({\n                type: \"tool-call-args-text-finish\",\n                path: [],\n              });\n              break;\n\n            default:\n              throw new Error(`Unexpected chunk type: ${chunk.type}`);\n          }\n        },\n      }),\n    );\n  }\n\n  get argsText() {\n    return this._argsTextController;\n  }\n\n  private _argsTextController!: TextStreamController;\n\n  setResponse(response: ToolResponseInit<ReadonlyJSONValue>) {\n    this._controller.enqueue({\n      type: \"result\",\n      path: [],\n      artifact: response.artifact,\n      result: response.result,\n      isError: response.isError ?? false,\n    });\n  }\n\n  async close() {\n    if (this._isClosed) return;\n\n    this._isClosed = true;\n    this._argsTextController.close();\n    await this._mergeTask;\n\n    this._controller.enqueue({\n      type: \"part-finish\",\n      path: [],\n    });\n    this._controller.close();\n  }\n}\n\nexport const createToolCallStream = (\n  readable: UnderlyingReadable<ToolCallStreamController>,\n): AssistantStream => {\n  return new ReadableStream({\n    start(c) {\n      return readable.start?.(new ToolCallStreamControllerImpl(c));\n    },\n    pull(c) {\n      return readable.pull?.(new ToolCallStreamControllerImpl(c));\n    },\n    cancel(c) {\n      return readable.cancel?.(c);\n    },\n  });\n};\n\nexport const createToolCallStreamController = () => {\n  let controller!: ToolCallStreamController;\n  const stream = createToolCallStream({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [stream, controller] as const;\n};\n","export class Counter {\n  public value = -1;\n\n  up() {\n    return ++this.value;\n  }\n}\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { Counter } from \"../Counter\";\n\nexport class PathAppendEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        controller.enqueue({\n          ...chunk,\n          path: [idx, ...chunk.path],\n        });\n      },\n    });\n  }\n}\n\nexport class PathAppendDecoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(idx: number) {\n    super({\n      transform(chunk, controller) {\n        const {\n          path: [idx2, ...path],\n        } = chunk;\n\n        if (idx !== idx2)\n          throw new Error(`Path mismatch: expected ${idx}, got ${idx2}`);\n\n        controller.enqueue({\n          ...chunk,\n          path,\n        });\n      },\n    });\n  }\n}\n\nexport class PathMergeEncoder extends TransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(counter: Counter) {\n    const innerCounter = new Counter();\n    const mapping = new Map<number, number>();\n    super({\n      transform(chunk, controller) {\n        if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n          mapping.set(innerCounter.up(), counter.up());\n        }\n\n        const [idx, ...path] = chunk.path;\n        if (idx === undefined) {\n          controller.enqueue(chunk);\n          return;\n        }\n        const mappedIdx = mapping.get(idx);\n        if (mappedIdx === undefined) throw new Error(\"Path not found\");\n\n        controller.enqueue({\n          ...chunk,\n          path: [mappedIdx, ...path],\n        });\n      },\n    });\n  }\n}\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport {\n  AssistantStreamController,\n  createAssistantStreamController,\n} from \"../../modules/assistant-stream\";\n\ntype AssistantTransformerFlushCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerStartCallback = (\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformerTransformCallback<I> = (\n  chunk: I,\n  controller: AssistantStreamController,\n) => void | PromiseLike<void>;\n\ntype AssistantTransformer<I> = {\n  flush?: AssistantTransformerFlushCallback;\n  start?: AssistantTransformerStartCallback;\n  transform?: AssistantTransformerTransformCallback<I>;\n};\n\nexport class AssistantTransformStream<I> extends TransformStream<\n  I,\n  AssistantStreamChunk\n> {\n  constructor(\n    transformer: AssistantTransformer<I>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<AssistantStreamChunk>,\n  ) {\n    const [stream, runController] = createAssistantStreamController();\n\n    let runPipeTask: Promise<void>;\n    super(\n      {\n        start(controller) {\n          runPipeTask = stream\n            .pipeTo(\n              new WritableStream({\n                write(chunk) {\n                  controller.enqueue(chunk);\n                },\n                abort(reason?: any) {\n                  controller.error(reason);\n                },\n                close() {\n                  controller.terminate();\n                },\n              }),\n            )\n            .catch((error) => {\n              controller.error(error);\n            });\n\n          return transformer.start?.(runController);\n        },\n        transform(chunk) {\n          return transformer.transform?.(chunk, runController);\n        },\n        async flush() {\n          await transformer.flush?.(runController);\n          runController.close();\n          await runPipeTask;\n        },\n      },\n      writableStrategy,\n      readableStrategy,\n    );\n  }\n}\n","export class PipeableTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(transform: (readable: ReadableStream<I>) => ReadableStream<O>) {\n    super();\n    const readable = transform(super.readable as unknown as ReadableStream<I>);\n    Object.defineProperty(this, \"readable\", {\n      value: readable,\n      writable: false,\n    });\n  }\n}\n","export class LineDecoderStream extends TransformStream<string, string> {\n  private buffer = \"\";\n\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        this.buffer += chunk;\n        const lines = this.buffer.split(\"\\n\");\n\n        // Process all complete lines\n        for (let i = 0; i < lines.length - 1; i++) {\n          controller.enqueue(lines[i]);\n        }\n\n        // Keep the last incomplete line in the buffer\n        this.buffer = lines[lines.length - 1] || \"\";\n      },\n      flush: (controller) => {\n        // flush any remaining content in the buffer\n        if (this.buffer) {\n          controller.enqueue(this.buffer);\n        }\n      },\n    });\n  }\n}\n","import { DataStreamChunk, DataStreamStreamChunkType } from \"./chunk-types\";\n\nexport class DataStreamChunkEncoder extends TransformStream<\n  DataStreamChunk,\n  string\n> {\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        controller.enqueue(`${chunk.type}:${JSON.stringify(chunk.value)}\\n`);\n      },\n    });\n  }\n}\n\nexport class DataStreamChunkDecoder extends TransformStream<\n  string,\n  DataStreamChunk\n> {\n  constructor() {\n    super({\n      transform: (chunk, controller) => {\n        const index = chunk.indexOf(\":\");\n        if (index === -1) throw new Error(\"Invalid stream part\");\n        controller.enqueue({\n          type: chunk.slice(0, index) as DataStreamStreamChunkType,\n          value: JSON.parse(chunk.slice(index + 1)),\n        });\n      },\n    });\n  }\n}\n","import { AssistantStreamChunk, PartInit } from \"../../AssistantStreamChunk\";\n\n/**\n * For chunk types that are associated with a part,\n * we require a nonâ€‘nullable meta field.\n */\nexport type AssistantMetaStreamChunk =\n  | (AssistantStreamChunk & {\n      type: \"text-delta\" | \"part-finish\";\n      meta: PartInit;\n    })\n  | (AssistantStreamChunk & {\n      type: \"result\" | \"tool-call-args-text-finish\";\n      meta: PartInit & { type: \"tool-call\" };\n    })\n  | (AssistantStreamChunk & {\n      type: Exclude<\n        AssistantStreamChunk[\"type\"],\n        \"text-delta\" | \"result\" | \"tool-call-args-text-finish\" | \"part-finish\"\n      >;\n    });\nexport class AssistantMetaTransformStream extends TransformStream<\n  AssistantStreamChunk,\n  AssistantMetaStreamChunk\n> {\n  constructor() {\n    // We use an array to record parts as they are introduced.\n    const parts: PartInit[] = [];\n\n    super({\n      transform(chunk, controller) {\n        // For chunks that introduce a new part.\n        if (chunk.type === \"part-start\") {\n          if (chunk.path.length !== 0) {\n            controller.error(new Error(\"Nested parts are not supported\"));\n            return;\n          }\n          parts.push(chunk.part);\n          controller.enqueue(chunk);\n          return;\n        }\n\n        // For chunks that expect an associated part.\n        if (\n          chunk.type === \"text-delta\" ||\n          chunk.type === \"result\" ||\n          chunk.type === \"part-finish\" ||\n          chunk.type === \"tool-call-args-text-finish\"\n        ) {\n          if (chunk.path.length !== 1) {\n            controller.error(\n              new Error(`${chunk.type} chunks must have a path of length 1`),\n            );\n            return;\n          }\n          const idx = chunk.path[0]!;\n          if (idx < 0 || idx >= parts.length) {\n            controller.error(new Error(`Invalid path index: ${idx}`));\n            return;\n          }\n          const part = parts[idx]!;\n\n          controller.enqueue({\n            ...chunk,\n            meta: part as any, // TODO\n          });\n          return;\n        }\n\n        controller.enqueue(chunk);\n      },\n    });\n  }\n}\n","import { AssistantStreamChunk } from \"../../AssistantStreamChunk\";\nimport { ToolCallStreamController } from \"../../modules/tool-call\";\nimport { AssistantTransformStream } from \"../../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../../utils/stream/PipeableTransformStream\";\nimport { DataStreamChunk, DataStreamStreamChunkType } from \"./chunk-types\";\nimport { LineDecoderStream } from \"../../utils/stream/LineDecoderStream\";\nimport {\n  DataStreamChunkDecoder,\n  DataStreamChunkEncoder,\n} from \"./serialization\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../../utils/stream/AssistantMetaTransformStream\";\nimport { TextStreamController } from \"../../modules/text\";\nimport { AssistantStreamEncoder } from \"../../AssistantStream\";\n\nexport class DataStreamEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        DataStreamChunk\n      >({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"part-start\": {\n              const part = chunk.part;\n              if (part.type === \"tool-call\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.StartToolCall,\n                  value,\n                });\n              }\n              if (part.type === \"source\") {\n                const { type, ...value } = part;\n                controller.enqueue({\n                  type: DataStreamStreamChunkType.Source,\n                  value,\n                });\n              }\n              break;\n            }\n            case \"text-delta\": {\n              const part = chunk.meta;\n              switch (part.type) {\n                case \"text\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.TextDelta,\n                    value: chunk.textDelta,\n                  });\n                  break;\n                }\n                case \"reasoning\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.ReasoningDelta,\n                    value: chunk.textDelta,\n                  });\n                  break;\n                }\n                case \"tool-call\": {\n                  controller.enqueue({\n                    type: DataStreamStreamChunkType.ToolCallArgsTextDelta,\n                    value: {\n                      toolCallId: part.toolCallId,\n                      argsTextDelta: chunk.textDelta,\n                    },\n                  });\n                  break;\n                }\n                default:\n                  throw new Error(\n                    `Unsupported part type for text-delta: ${part.type}`,\n                  );\n              }\n              break;\n            }\n            case \"result\": {\n              // Only tool-call parts can have results.\n              const part = chunk.meta;\n              if (part.type !== \"tool-call\") {\n                throw new Error(\n                  `Result chunk on non-tool-call part not supported: ${part.type}`,\n                );\n              }\n              controller.enqueue({\n                type: DataStreamStreamChunkType.ToolCallResult,\n                value: {\n                  toolCallId: part.toolCallId,\n                  result: chunk.result,\n                  artifact: chunk.artifact,\n                  ...(chunk.isError ? { isError: chunk.isError } : {}),\n                },\n              });\n              break;\n            }\n            case \"step-start\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.StartStep,\n                value,\n              });\n              break;\n            }\n            case \"step-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishStep,\n                value,\n              });\n              break;\n            }\n            case \"message-finish\": {\n              const { type, ...value } = chunk;\n              controller.enqueue({\n                type: DataStreamStreamChunkType.FinishMessage,\n                value,\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Error,\n                value: chunk.error,\n              });\n              break;\n            }\n            case \"annotations\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Annotation,\n                value: chunk.annotations,\n              });\n              break;\n            }\n            case \"data\": {\n              controller.enqueue({\n                type: DataStreamStreamChunkType.Data,\n                value: chunk.data,\n              });\n              break;\n            }\n\n            // TODO ignore for now\n            // in the future, we should create a handler that waits for text parts to finish before continuing\n            case \"tool-call-args-text-finish\":\n            case \"part-finish\":\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`Unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform)\n        .pipeThrough(new DataStreamChunkEncoder())\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nconst TOOL_CALL_ARGS_CLOSING_CHUNKS = [\n  DataStreamStreamChunkType.StartToolCall,\n  DataStreamStreamChunkType.ToolCall,\n  DataStreamStreamChunkType.TextDelta,\n  DataStreamStreamChunkType.ReasoningDelta,\n  DataStreamStreamChunkType.Source,\n  DataStreamStreamChunkType.Error,\n  DataStreamStreamChunkType.FinishStep,\n  DataStreamStreamChunkType.FinishMessage,\n];\n\nexport class DataStreamDecoder extends PipeableTransformStream<\n  Uint8Array,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const toolCallControllers = new Map<string, ToolCallStreamController>();\n      let activeToolCallArgsText: TextStreamController | undefined;\n      const transform = new AssistantTransformStream<DataStreamChunk>({\n        transform(chunk, controller) {\n          const { type, value } = chunk;\n\n          if (TOOL_CALL_ARGS_CLOSING_CHUNKS.includes(type)) {\n            activeToolCallArgsText?.close();\n            activeToolCallArgsText = undefined;\n          }\n\n          switch (type) {\n            case DataStreamStreamChunkType.ReasoningDelta:\n              controller.appendReasoning(value);\n              break;\n\n            case DataStreamStreamChunkType.TextDelta:\n              controller.appendText(value);\n              break;\n\n            case DataStreamStreamChunkType.StartToolCall: {\n              const { toolCallId, toolName } = value;\n              const toolCallController = controller.addToolCallPart({\n                toolCallId,\n                toolName,\n              });\n              toolCallControllers.set(toolCallId, toolCallController);\n\n              activeToolCallArgsText = toolCallController.argsText;\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallArgsTextDelta: {\n              const { toolCallId, argsTextDelta } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call with unknown id: \" + toolCallId,\n                );\n              toolCallController.argsText.append(argsTextDelta);\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCallResult: {\n              const { toolCallId, artifact, result, isError } = value;\n              const toolCallController = toolCallControllers.get(toolCallId);\n              if (!toolCallController)\n                throw new Error(\n                  \"Encountered tool call result with unknown id: \" + toolCallId,\n                );\n              toolCallController.setResponse({\n                artifact,\n                result,\n                isError,\n              });\n              break;\n            }\n\n            case DataStreamStreamChunkType.ToolCall: {\n              const { toolCallId, toolName, args } = value;\n\n              let toolCallController = toolCallControllers.get(toolCallId);\n              if (toolCallController) {\n                toolCallController.argsText.close();\n              } else {\n                toolCallController = controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                  args,\n                });\n                toolCallControllers.set(toolCallId, toolCallController);\n              }\n              break;\n            }\n\n            case DataStreamStreamChunkType.FinishMessage:\n              controller.enqueue({\n                type: \"message-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.StartStep:\n              controller.enqueue({\n                type: \"step-start\",\n                path: [],\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.FinishStep:\n              controller.enqueue({\n                type: \"step-finish\",\n                path: [],\n                ...value,\n              });\n              break;\n            case DataStreamStreamChunkType.Data:\n              controller.enqueue({\n                type: \"data\",\n                path: [],\n                data: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Annotation:\n              controller.enqueue({\n                type: \"annotations\",\n                path: [],\n                annotations: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Source:\n              controller.appendSource({\n                type: \"source\",\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.Error:\n              controller.enqueue({\n                type: \"error\",\n                path: [],\n                error: value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.File:\n              controller.appendFile({\n                type: \"file\",\n                ...value,\n              });\n              break;\n\n            case DataStreamStreamChunkType.ReasoningSignature:\n            case DataStreamStreamChunkType.RedactedReasoning:\n              // ignore these for now\n              break;\n\n            default: {\n              const exhaustiveCheck: never = type;\n              throw new Error(`unsupported chunk type: ${exhaustiveCheck}`);\n            }\n          }\n        },\n        flush() {\n          activeToolCallArgsText?.close();\n          activeToolCallArgsText = undefined;\n          toolCallControllers.forEach((controller) => controller.close());\n          toolCallControllers.clear();\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new LineDecoderStream())\n        .pipeThrough(new DataStreamChunkDecoder())\n        .pipeThrough(transform);\n    });\n  }\n}\n","import { customAlphabet } from \"nanoid/non-secure\";\n\nexport const generateId = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7,\n);\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantStreamChunk, PartInit } from \"../AssistantStreamChunk\";\nimport { createMergeStream } from \"../utils/stream/merge\";\nimport { createTextStreamController, TextStreamController } from \"./text\";\nimport {\n  createToolCallStreamController,\n  ToolCallStreamController,\n} from \"./tool-call\";\nimport { Counter } from \"../utils/Counter\";\nimport {\n  PathAppendEncoder,\n  PathMergeEncoder,\n} from \"../utils/stream/path-utils\";\nimport { DataStreamEncoder } from \"../serialization/data-stream/DataStream\";\nimport { FilePart, SourcePart } from \"../utils/types\";\nimport { generateId } from \"../utils/generateId\";\nimport {\n  ReadonlyJSONObject,\n  ReadonlyJSONValue,\n} from \"../utils/json/json-value\";\nimport { ToolResponseInit } from \"../ToolResponse\";\n\ntype ToolCallPartInit = {\n  toolCallId?: string;\n  toolName: string;\n  argsText?: string;\n  args?: ReadonlyJSONObject;\n  response?: ToolResponseInit<ReadonlyJSONValue>;\n};\n\nexport type AssistantStreamController = {\n  appendText(textDelta: string): void;\n  appendReasoning(reasoningDelta: string): void;\n  appendSource(options: SourcePart): void;\n  appendFile(options: FilePart): void;\n  addTextPart(): TextStreamController;\n  addToolCallPart(options: string): ToolCallStreamController;\n  addToolCallPart(options: ToolCallPartInit): ToolCallStreamController;\n  enqueue(chunk: AssistantStreamChunk): void;\n  merge(stream: AssistantStream): void;\n  close(): void;\n};\n\nclass AssistantStreamControllerImpl implements AssistantStreamController {\n  private _merger = createMergeStream();\n  private _append:\n    | {\n        controller: TextStreamController;\n        kind: \"text\" | \"reasoning\";\n      }\n    | undefined;\n  private _contentCounter = new Counter();\n\n  get __internal_isClosed() {\n    return this._merger.isSealed();\n  }\n\n  __internal_getReadable() {\n    return this._merger.readable;\n  }\n\n  private _closeSubscriber: undefined | (() => void);\n  __internal_subscribeToClose(callback: () => void) {\n    this._closeSubscriber = callback;\n  }\n\n  private _addPart(part: PartInit, stream: AssistantStream) {\n    if (this._append) {\n      this._append.controller.close();\n      this._append = undefined;\n    }\n\n    this.enqueue({\n      type: \"part-start\",\n      part,\n      path: [],\n    });\n    this._merger.addStream(\n      stream.pipeThrough(new PathAppendEncoder(this._contentCounter.value)),\n    );\n  }\n\n  merge(stream: AssistantStream) {\n    this._merger.addStream(\n      stream.pipeThrough(new PathMergeEncoder(this._contentCounter)),\n    );\n  }\n\n  appendText(textDelta: string) {\n    if (this._append?.kind !== \"text\") {\n      this._append = {\n        kind: \"text\",\n        controller: this.addTextPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  appendReasoning(textDelta: string) {\n    if (this._append?.kind !== \"reasoning\") {\n      this._append = {\n        kind: \"reasoning\",\n        controller: this.addReasoningPart(),\n      };\n    }\n    this._append.controller.append(textDelta);\n  }\n\n  addTextPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"text\" }, stream);\n    return controller;\n  }\n\n  addReasoningPart() {\n    const [stream, controller] = createTextStreamController();\n    this._addPart({ type: \"reasoning\" }, stream);\n    return controller;\n  }\n\n  addToolCallPart(\n    options: string | ToolCallPartInit,\n  ): ToolCallStreamController {\n    const opt = typeof options === \"string\" ? { toolName: options } : options;\n    const toolName = opt.toolName;\n    const toolCallId = opt.toolCallId ?? generateId();\n\n    const [stream, controller] = createToolCallStreamController();\n    this._addPart({ type: \"tool-call\", toolName, toolCallId }, stream);\n\n    if (opt.argsText !== undefined) {\n      controller.argsText.append(opt.argsText);\n      controller.argsText.close();\n    }\n    if (opt.args !== undefined) {\n      controller.argsText.append(JSON.stringify(opt.args));\n      controller.argsText.close();\n    }\n    if (opt.response !== undefined) {\n      controller.setResponse(opt.response);\n    }\n\n    return controller;\n  }\n\n  appendSource(options: SourcePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  appendFile(options: FilePart) {\n    this._addPart(\n      options,\n      new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"part-finish\",\n            path: [],\n          });\n          controller.close();\n        },\n      }),\n    );\n  }\n\n  enqueue(chunk: AssistantStreamChunk) {\n    this._merger.enqueue(chunk);\n\n    if (chunk.type === \"part-start\" && chunk.path.length === 0) {\n      this._contentCounter.up();\n    }\n  }\n\n  close() {\n    this._merger.seal();\n    this._append?.controller?.close();\n\n    this._closeSubscriber?.();\n  }\n}\n\nexport function createAssistantStream(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n): AssistantStream {\n  const controller = new AssistantStreamControllerImpl();\n\n  let promiseOrVoid: PromiseLike<void> | void;\n  try {\n    promiseOrVoid = callback(controller);\n  } catch (e) {\n    if (!controller.__internal_isClosed) {\n      controller.enqueue({\n        type: \"error\",\n        path: [],\n        error: String(e),\n      });\n      controller.close();\n    }\n    throw e;\n  }\n\n  if (promiseOrVoid instanceof Promise) {\n    const runTask = async () => {\n      try {\n        await promiseOrVoid;\n      } catch (e) {\n        if (!controller.__internal_isClosed) {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(e),\n          });\n        }\n        throw e;\n      } finally {\n        if (!controller.__internal_isClosed) {\n          controller.close();\n        }\n      }\n    };\n    runTask();\n  } else {\n    if (!controller.__internal_isClosed) {\n      controller.close();\n    }\n  }\n\n  return controller.__internal_getReadable();\n}\n\nconst promiseWithResolvers = function <T>() {\n  let resolve: ((value: T | PromiseLike<T>) => void) | undefined;\n  let reject: ((reason?: unknown) => void) | undefined;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  if (!resolve || !reject) throw new Error(\"Failed to create promise\");\n  return { promise, resolve, reject };\n};\n\nexport function createAssistantStreamController() {\n  const { resolve, promise } = promiseWithResolvers<void>();\n  let controller!: AssistantStreamController;\n  const stream = createAssistantStream((c) => {\n    controller = c;\n\n    (controller as AssistantStreamControllerImpl).__internal_subscribeToClose(\n      resolve,\n    );\n\n    return promise;\n  });\n  return [stream, controller] as const;\n}\n\nexport function createAssistantStreamResponse(\n  callback: (controller: AssistantStreamController) => PromiseLike<void> | void,\n) {\n  return AssistantStream.toResponse(\n    createAssistantStream(callback),\n    new DataStreamEncoder(),\n  );\n}\n","import sjson from \"secure-json-parse\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport {\n  AssistantMetaStreamChunk,\n  AssistantMetaTransformStream,\n} from \"../utils/stream/AssistantMetaTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\nimport { ReadonlyJSONValue } from \"../utils/json/json-value\";\nimport { ToolResponse } from \"../ToolResponse\";\nimport { withPromiseOrValue } from \"../utils/withPromiseOrValue\";\n\ntype ToolCallback = (toolCall: {\n  toolCallId: string;\n  toolName: string;\n  args: unknown;\n}) =>\n  | Promise<ToolResponse<ReadonlyJSONValue>>\n  | ToolResponse<ReadonlyJSONValue>\n  | undefined;\n\nexport class ToolExecutionStream extends PipeableTransformStream<\n  AssistantStreamChunk,\n  AssistantStreamChunk\n> {\n  constructor(toolCallback: ToolCallback) {\n    const toolCallPromises = new Map<string, PromiseLike<void>>();\n    const toolCallArgsText: Record<string, string> = {};\n    super((readable) => {\n      const transform = new TransformStream<\n        AssistantMetaStreamChunk,\n        AssistantStreamChunk\n      >({\n        transform(chunk, controller) {\n          // forward everything\n          if (chunk.type !== \"part-finish\" || chunk.meta.type !== \"tool-call\") {\n            controller.enqueue(chunk);\n          }\n\n          const type = chunk.type;\n\n          switch (type) {\n            case \"text-delta\": {\n              if (chunk.meta.type === \"tool-call\") {\n                const toolCallId = chunk.meta.toolCallId;\n                if (toolCallArgsText[toolCallId] === undefined) {\n                  toolCallArgsText[toolCallId] = chunk.textDelta;\n                } else {\n                  toolCallArgsText[toolCallId] += chunk.textDelta;\n                }\n              }\n              break;\n            }\n            case \"tool-call-args-text-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId, toolName } = chunk.meta;\n              const argsText = toolCallArgsText[toolCallId];\n\n              const promise = withPromiseOrValue(\n                () => {\n                  if (!argsText) {\n                    console.log(\n                      \"Encountered tool call without argsText, this should never happen\",\n                    );\n                    throw new Error(\n                      \"Encountered tool call without argsText, this is unexpected.\",\n                    );\n                  }\n\n                  let args;\n                  try {\n                    args = sjson.parse(argsText);\n                  } catch (e) {\n                    throw new Error(\n                      `Function parameter parsing failed. ${JSON.stringify((e as Error).message)}`,\n                    );\n                  }\n\n                  return toolCallback({\n                    toolCallId,\n                    toolName,\n                    args,\n                  });\n                },\n                (c) => {\n                  if (c === undefined) return;\n\n                  // TODO how to handle new ToolResult({ result: undefined })?\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    artifact: c.artifact,\n                    result: c.result,\n                    isError: c.isError,\n                  });\n                },\n                (e) => {\n                  controller.enqueue({\n                    type: \"result\",\n                    path: chunk.path,\n                    result: String(e),\n                    isError: true,\n                  });\n                },\n              );\n              if (promise) {\n                toolCallPromises.set(toolCallId, promise);\n              }\n              break;\n            }\n\n            case \"part-finish\": {\n              if (chunk.meta.type !== \"tool-call\") break;\n\n              const { toolCallId } = chunk.meta;\n              const toolCallPromise = toolCallPromises.get(toolCallId);\n              if (toolCallPromise) {\n                toolCallPromise.then(() => {\n                  controller.enqueue(chunk);\n                });\n              } else {\n                controller.enqueue(chunk);\n              }\n            }\n          }\n        },\n        async flush() {\n          await Promise.all(toolCallPromises.values());\n        },\n      });\n\n      return readable\n        .pipeThrough(new AssistantMetaTransformStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n","export function withPromiseOrValue<T>(\n  callback: () => T | PromiseLike<T>,\n  thenHandler: (value: T) => PromiseLike<void> | void,\n  catchHandler: (error: unknown) => PromiseLike<void> | void,\n): PromiseLike<void> | void {\n  try {\n    const promiseOrValue = callback();\n    if (\n      typeof promiseOrValue === \"object\" &&\n      promiseOrValue !== null &&\n      \"then\" in promiseOrValue\n    ) {\n      return promiseOrValue.then(thenHandler, catchHandler);\n    } else {\n      thenHandler(promiseOrValue);\n    }\n  } catch (e) {\n    catchHandler(e);\n  }\n}\n","import sjson from \"secure-json-parse\";\nimport { fixJson } from \"./fix-json\";\n\nexport const parsePartialJson = (json: string) => {\n  try {\n    return sjson.parse(json);\n  } catch {\n    try {\n      return sjson.parse(fixJson(json));\n    } catch {\n      return undefined;\n    }\n  }\n};\n","// LICENSE for this file only\n\n// Copyright 2023 Vercel, Inc.\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n//     http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ntype State =\n  | \"ROOT\"\n  | \"FINISH\"\n  | \"INSIDE_STRING\"\n  | \"INSIDE_STRING_ESCAPE\"\n  | \"INSIDE_LITERAL\"\n  | \"INSIDE_NUMBER\"\n  | \"INSIDE_OBJECT_START\"\n  | \"INSIDE_OBJECT_KEY\"\n  | \"INSIDE_OBJECT_AFTER_KEY\"\n  | \"INSIDE_OBJECT_BEFORE_VALUE\"\n  | \"INSIDE_OBJECT_AFTER_VALUE\"\n  | \"INSIDE_OBJECT_AFTER_COMMA\"\n  | \"INSIDE_ARRAY_START\"\n  | \"INSIDE_ARRAY_AFTER_VALUE\"\n  | \"INSIDE_ARRAY_AFTER_COMMA\";\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i]!;\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n\n          case \",\": {\n            stack.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case \"}\": {\n            stack.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case \"]\": {\n            stack.pop();\n\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !\"false\".startsWith(partialLiteral) &&\n          !\"true\".startsWith(partialLiteral) &&\n          !\"null\".startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { generateId } from \"../utils/generateId\";\nimport { ReadonlyJSONObject } from \"../utils/json/json-value\";\nimport { parsePartialJson } from \"../utils/json/parse-partial-json\";\nimport {\n  AssistantMessage,\n  AssistantMessageStatus,\n  TextPart,\n  ToolCallPart,\n  SourcePart,\n  AssistantMessagePart,\n  ReasoningPart,\n  FilePart,\n} from \"../utils/types\";\n\nconst createInitialMessage = (): AssistantMessage => ({\n  role: \"assistant\",\n  status: { type: \"running\" },\n  parts: [],\n  get content() {\n    return this.parts;\n  },\n  metadata: {\n    unstable_data: [],\n    unstable_annotations: [],\n    steps: [],\n    custom: {},\n  },\n});\n\nconst updatePartForPath = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk,\n  updater: (part: AssistantMessagePart) => AssistantMessagePart,\n): AssistantMessage => {\n  if (message.parts.length === 0) {\n    throw new Error(\"No parts available to update.\");\n  }\n\n  if (chunk.path.length !== 1)\n    throw new Error(\"Nested paths are not supported yet.\");\n\n  const partIndex = chunk.path[0]!;\n  const updatedPart = updater(message.parts[partIndex]!);\n  return {\n    ...message,\n    parts: [\n      ...message.parts.slice(0, partIndex),\n      updatedPart,\n      ...message.parts.slice(partIndex + 1),\n    ],\n    get content() {\n      return this.parts;\n    },\n  };\n};\n\nconst handlePartStart = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { readonly type: \"part-start\" },\n): AssistantMessage => {\n  const partInit = chunk.part;\n  if (partInit.type === \"text\" || partInit.type === \"reasoning\") {\n    const newTextPart: TextPart | ReasoningPart = {\n      type: partInit.type,\n      text: \"\",\n      status: { type: \"running\" },\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newTextPart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"tool-call\") {\n    const newToolCallPart: ToolCallPart = {\n      type: \"tool-call\",\n      state: \"partial-call\",\n      status: { type: \"running\", isArgsComplete: false },\n      toolCallId: partInit.toolCallId,\n      toolName: partInit.toolName,\n      argsText: \"\",\n      args: {},\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newToolCallPart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"source\") {\n    const newSourcePart: SourcePart = {\n      type: \"source\",\n      sourceType: partInit.sourceType,\n      id: partInit.id,\n      url: partInit.url,\n      ...(partInit.title ? { title: partInit.title } : undefined),\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newSourcePart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else if (partInit.type === \"file\") {\n    const newFilePart: FilePart = {\n      type: \"file\",\n      mimeType: partInit.mimeType,\n      data: partInit.data,\n    };\n    return {\n      ...message,\n      parts: [...message.parts, newFilePart],\n      get content() {\n        return this.parts;\n      },\n    };\n  } else {\n    throw new Error(`Unsupported part type: ${partInit.type}`);\n  }\n};\n\nconst handleToolCallArgsTextFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & {\n    readonly type: \"tool-call-args-text-finish\";\n  },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type !== \"tool-call\") {\n      throw new Error(\"Last is not a tool call\");\n    }\n    return {\n      ...part,\n      state: \"call\",\n    };\n  });\n};\n\nconst handlePartFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { readonly type: \"part-finish\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => ({\n    ...part,\n    status: { type: \"complete\", reason: \"unknown\" },\n  }));\n};\n\nconst handleTextDelta = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"text-delta\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type === \"text\") {\n      return { ...part, text: part.text + chunk.textDelta };\n    } else if (part.type === \"tool-call\") {\n      const newArgsText = part.argsText + chunk.textDelta;\n      let newArgs: ReadonlyJSONObject;\n      try {\n        newArgs = parsePartialJson(newArgsText);\n      } catch (err) {\n        newArgs = part.args;\n      }\n      return { ...part, argsText: newArgsText, args: newArgs };\n    } else {\n      throw new Error(\n        \"text-delta received but part is neither text nor tool-call\",\n      );\n    }\n  });\n};\n\nconst handleResult = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"result\" },\n): AssistantMessage => {\n  return updatePartForPath(message, chunk, (part) => {\n    if (part.type === \"tool-call\") {\n      return {\n        ...part,\n        state: \"result\",\n        artifact: chunk.artifact,\n        result: chunk.result,\n        isError: chunk.isError ?? false,\n        status: { type: \"complete\", reason: \"stop\" },\n      };\n    } else {\n      throw new Error(\"Result chunk received but part is not a tool-call\");\n    }\n  });\n};\n\nconst handleMessageFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"message-finish\" },\n): AssistantMessage => {\n  const newStatus = getStatus(chunk);\n  return { ...message, status: newStatus };\n};\n\nconst getStatus = (\n  chunk:\n    | (AssistantStreamChunk & { type: \"message-finish\" })\n    | (AssistantStreamChunk & { type: \"step-finish\" }),\n): AssistantMessageStatus => {\n  if (chunk.finishReason === \"tool-calls\") {\n    return {\n      type: \"requires-action\",\n      reason: \"tool-calls\",\n    };\n  } else if (\n    chunk.finishReason === \"stop\" ||\n    chunk.finishReason === \"unknown\"\n  ) {\n    return {\n      type: \"complete\",\n      reason: chunk.finishReason,\n    };\n  } else {\n    return {\n      type: \"incomplete\",\n      reason: chunk.finishReason,\n    };\n  }\n};\n\nconst handleAnnotations = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"annotations\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_annotations: [\n        ...message.metadata.unstable_annotations,\n        ...chunk.annotations,\n      ],\n    },\n  };\n};\n\nconst handleData = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"data\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_data: [...message.metadata.unstable_data, ...chunk.data],\n    },\n  };\n};\n\nconst handleStepStart = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"step-start\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      steps: [\n        ...message.metadata.steps,\n        { state: \"started\", messageId: chunk.messageId },\n      ],\n    },\n  };\n};\n\nconst handleStepFinish = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"step-finish\" },\n): AssistantMessage => {\n  const steps = message.metadata.steps.slice();\n  const lastIndex = steps.length - 1;\n\n  // Check if the previous step is a step-start (has state \"started\")\n  if (steps.length > 0 && steps[lastIndex]?.state === \"started\") {\n    steps[lastIndex] = {\n      ...steps[lastIndex],\n      state: \"finished\",\n      finishReason: chunk.finishReason,\n      usage: chunk.usage,\n      isContinued: chunk.isContinued,\n    };\n  } else {\n    // If no previous step-start exists, append a finished step\n    steps.push({\n      state: \"finished\",\n      messageId: generateId(),\n      finishReason: chunk.finishReason,\n      usage: chunk.usage,\n      isContinued: chunk.isContinued,\n    });\n  }\n\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      steps,\n    },\n  };\n};\n\nconst handleErrorChunk = (\n  message: AssistantMessage,\n  chunk: AssistantStreamChunk & { type: \"error\" },\n): AssistantMessage => {\n  return {\n    ...message,\n    status: { type: \"incomplete\", reason: \"error\", error: chunk.error },\n  };\n};\n\nexport class AssistantMessageAccumulator extends TransformStream<\n  AssistantStreamChunk,\n  AssistantMessage\n> {\n  constructor({\n    initialMessage,\n  }: {\n    initialMessage?: AssistantMessage;\n  } = {}) {\n    let message = initialMessage ?? createInitialMessage();\n    super({\n      transform(chunk, controller) {\n        const type = chunk.type;\n        switch (type) {\n          case \"part-start\":\n            message = handlePartStart(message, chunk);\n            break;\n\n          case \"tool-call-args-text-finish\":\n            message = handleToolCallArgsTextFinish(message, chunk);\n            break;\n\n          case \"part-finish\":\n            message = handlePartFinish(message, chunk);\n            break;\n\n          case \"text-delta\":\n            message = handleTextDelta(message, chunk);\n            break;\n          case \"result\":\n            message = handleResult(message, chunk);\n            break;\n          case \"message-finish\":\n            message = handleMessageFinish(message, chunk);\n            break;\n          case \"annotations\":\n            message = handleAnnotations(message, chunk);\n            break;\n          case \"data\":\n            message = handleData(message, chunk);\n            break;\n          case \"step-start\":\n            message = handleStepStart(message, chunk);\n            break;\n          case \"step-finish\":\n            message = handleStepFinish(message, chunk);\n            break;\n          case \"error\":\n            message = handleErrorChunk(message, chunk);\n            break;\n          default: {\n            const unhandledType: never = type;\n            throw new Error(`Unsupported chunk type: ${unhandledType}`);\n          }\n        }\n        controller.enqueue(message);\n      },\n      flush(controller) {\n        if (message.status?.type === \"running\") {\n          // TODO this test isn't sound\n          const requiresAction = message.parts?.at(-1)?.type === \"tool-call\";\n          message = handleMessageFinish(message, {\n            type: \"message-finish\",\n            path: [],\n            finishReason: requiresAction ? \"tool-calls\" : \"unknown\",\n            usage: {\n              promptTokens: 0,\n              completionTokens: 0,\n            },\n          });\n          controller.enqueue(message);\n        }\n      },\n    });\n  }\n}\n","import { AssistantStreamEncoder } from \"../AssistantStream\";\nimport { AssistantStreamChunk } from \"../AssistantStreamChunk\";\nimport { AssistantTransformStream } from \"../utils/stream/AssistantTransformStream\";\nimport { PipeableTransformStream } from \"../utils/stream/PipeableTransformStream\";\n\nexport class PlainTextEncoder\n  extends PipeableTransformStream<AssistantStreamChunk, Uint8Array>\n  implements AssistantStreamEncoder\n{\n  headers = new Headers({\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    \"x-vercel-ai-data-stream\": \"v1\",\n  });\n\n  constructor() {\n    super((readable) => {\n      const transform = new TransformStream<AssistantStreamChunk, string>({\n        transform(chunk, controller) {\n          const type = chunk.type;\n          switch (type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n\n            default:\n              const unsupportedType:\n                | \"part-start\"\n                | \"part-finish\"\n                | \"tool-call-args-text-finish\"\n                | \"data\"\n                | \"step-start\"\n                | \"step-finish\"\n                | \"message-finish\"\n                | \"annotations\"\n                | \"tool-call-begin\"\n                | \"tool-call-delta\"\n                | \"result\"\n                | \"error\" = type;\n              throw new Error(`unsupported chunk type: ${unsupportedType}`);\n          }\n        },\n      });\n\n      return readable\n        .pipeThrough(transform)\n        .pipeThrough(new TextEncoderStream());\n    });\n  }\n}\n\nexport class PlainTextDecoder extends PipeableTransformStream<\n  Uint8Array,\n  AssistantStreamChunk\n> {\n  constructor() {\n    super((readable) => {\n      const transform = new AssistantTransformStream<string>({\n        transform(chunk, controller) {\n          controller.appendText(chunk);\n        },\n      });\n\n      return readable\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(transform);\n    });\n  }\n}\n","import { AssistantStream } from \"../AssistantStream\";\nimport { AssistantMessage } from \"../utils/types\";\nimport { AssistantMessageAccumulator } from \"./assistant-message-accumulator\";\n\nexport class AssistantMessageStream {\n  constructor(public readonly readable: ReadableStream<AssistantMessage>) {\n    this.readable = readable;\n  }\n\n  static fromAssistantStream(stream: AssistantStream) {\n    return new AssistantMessageStream(\n      stream.pipeThrough(new AssistantMessageAccumulator()),\n    );\n  }\n\n  async unstable_result(): Promise<AssistantMessage> {\n    let last: AssistantMessage | undefined;\n    for await (const chunk of this) {\n      last = chunk;\n    }\n\n    if (!last) {\n      return {\n        role: \"assistant\",\n        status: { type: \"complete\", reason: \"unknown\" },\n        parts: [],\n        content: [],\n        metadata: {\n          unstable_data: [],\n          unstable_annotations: [],\n          steps: [],\n          custom: {},\n        },\n      };\n    }\n    return last;\n  }\n\n  [Symbol.asyncIterator]() {\n    const reader = this.readable.getReader();\n    return {\n      async next(): Promise<IteratorResult<AssistantMessage, undefined>> {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: undefined } : { done: false, value };\n      },\n    };\n  }\n\n  tee(): [AssistantMessageStream, AssistantMessageStream] {\n    const [readable1, readable2] = this.readable.tee();\n    return [\n      new AssistantMessageStream(readable1),\n      new AssistantMessageStream(readable2),\n    ];\n  }\n}\n","import { ReadonlyJSONValue } from \"./utils/json/json-value\";\n\nconst TOOL_RESPONSE_SYMBOL = Symbol.for(\"aui.tool-response\");\n\nexport type ToolResponseInit<TResult> = {\n  result: TResult;\n  artifact?: ReadonlyJSONValue | undefined;\n  isError?: boolean | undefined;\n};\n\nexport class ToolResponse<TResult> {\n  get [TOOL_RESPONSE_SYMBOL]() {\n    return true;\n  }\n\n  readonly artifact?: ReadonlyJSONValue | undefined;\n  readonly result: TResult;\n  readonly isError: boolean;\n\n  constructor(options: ToolResponseInit<TResult>) {\n    this.artifact = options.artifact;\n    this.result = options.result;\n    this.isError = options.isError ?? false;\n  }\n\n  static [Symbol.hasInstance](obj: unknown): obj is ToolResponse<unknown> {\n    return (\n      typeof obj === \"object\" && obj !== null && TOOL_RESPONSE_SYMBOL in obj\n    );\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACWO,IAAM,kBAAkB;AAAA,EAC7B,WAAW,QAAyB,aAAqC;AACvE,WAAO,IAAI,SAAS,gBAAgB,aAAa,QAAQ,WAAW,GAAG;AAAA,MACrE,SAAS,YAAY,WAAW,CAAC;AAAA,IACnC,CAAC;AAAA,EACH;AAAA,EAEA,aACE,UACA,aACA;AACA,WAAO,gBAAgB,eAAe,SAAS,MAAO,WAAW;AAAA,EACnE;AAAA,EAEA,aACE,QACA,aACA;AACA,WAAO,OAAO,YAAY,WAAW;AAAA,EACvC;AAAA,EAEA,eACE,UACA,aACA;AACA,WAAO,SAAS,YAAY,WAAW;AAAA,EACzC;AACF;;;AC/BA,IAAM,uBAAuB,MAAM;AACjC,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU,IAAI,QAAc,CAAC,KAAK,QAAQ;AAC9C,cAAU;AACV,aAAS;AAAA,EACX,CAAC;AACD,SAAO,EAAE,SAAS,SAAmB,OAAgB;AACvD;AAEO,IAAM,oBAAoB,MAAM;AACrC,QAAM,OAA0B,CAAC;AACjC,MAAI,SAAS;AACb,MAAI;AACJ,MAAI;AAEJ,QAAM,aAAa,CAAC,SAA0B;AAC5C,QAAI,CAAC,KAAK,SAAS;AAMjB,WAAK,UAAU,KAAK,OACjB,KAAK,EACL,KAAK,CAAC,EAAE,MAAM,MAAM,MAAM;AACzB,aAAK,UAAU;AACf,YAAI,MAAM;AACR,eAAK,OAAO,KAAK,QAAQ,IAAI,GAAG,CAAC;AACjC,cAAI,UAAU,KAAK,WAAW,GAAG;AAC/B,uBAAW,MAAM;AAAA,UACnB;AAAA,QACF,OAAO;AACL,qBAAW,QAAQ,KAAK;AAAA,QAC1B;AAEA,qBAAa,QAAQ;AACrB,sBAAc;AAAA,MAChB,CAAC,EACA,MAAM,CAAC,MAAM;AACZ,gBAAQ,MAAM,CAAC;AAEf,aAAK,QAAQ,CAACA,UAAS;AACrB,UAAAA,MAAK,OAAO,OAAO;AAAA,QACrB,CAAC;AACD,aAAK,SAAS;AAEd,mBAAW,MAAM,CAAC;AAElB,qBAAa,OAAO,CAAC;AACrB,sBAAc;AAAA,MAChB,CAAC;AAAA,IACL;AAAA,EACF;AAEA,QAAM,WAAW,IAAI,eAAqC;AAAA,IACxD,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,IACA,OAAO;AACL,oBAAc,qBAAqB;AACnC,WAAK,QAAQ,CAAC,SAAS;AACrB,mBAAW,IAAI;AAAA,MACjB,CAAC;AAED,aAAO,YAAY;AAAA,IACrB;AAAA,IACA,SAAS;AACP,WAAK,QAAQ,CAAC,SAAS;AACrB,aAAK,OAAO,OAAO;AAAA,MACrB,CAAC;AACD,WAAK,SAAS;AAAA,IAChB;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA,WAAW;AACT,aAAO;AAAA,IACT;AAAA,IACA,OAAO;AACL,eAAS;AACT,UAAI,KAAK,WAAW,EAAG,YAAW,MAAM;AAAA,IAC1C;AAAA,IACA,UAAU,QAA8C;AACtD,UAAI;AACF,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAEF,YAAM,OAAO,EAAE,QAAQ,OAAO,UAAU,EAAE;AAC1C,WAAK,KAAK,IAAI;AACd,iBAAW,IAAI;AAAA,IACjB;AAAA,IACA,QAAQ,OAA6B;AACnC,WAAK;AAAA,QACH,IAAI,eAAe;AAAA,UACjB,MAAM,GAAG;AACP,cAAE,QAAQ,KAAK;AACf,cAAE,MAAM;AAAA,UACV;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;ACvGA,IAAM,2BAAN,MAA+D;AAAA,EACrD;AAAA,EACA,YAAY;AAAA,EAEpB,YACE,YACA;AACA,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,OAAO,WAAmB;AACxB,SAAK,YAAY,QAAQ;AAAA,MACvB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,MACP;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ;AACN,QAAI,KAAK,UAAW;AACpB,SAAK,YAAY;AACjB,SAAK,YAAY,QAAQ;AAAA,MACvB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,IACT,CAAC;AACD,SAAK,YAAY,MAAM;AAAA,EACzB;AACF;AAEO,IAAM,mBAAmB,CAC9B,aACoB;AACpB,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,GAAG;AACP,aAAO,SAAS,QAAQ,IAAI,yBAAyB,CAAC,CAAC;AAAA,IACzD;AAAA,IACA,KAAK,GAAG;AACN,aAAO,SAAS,OAAO,IAAI,yBAAyB,CAAC,CAAC;AAAA,IACxD;AAAA,IACA,OAAO,GAAG;AACR,aAAO,SAAS,SAAS,CAAC;AAAA,IAC5B;AAAA,EACF,CAAC;AACH;AAEO,IAAM,6BAA6B,MAAM;AAC9C,MAAI;AACJ,QAAM,SAAS,iBAAiB;AAAA,IAC9B,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,EACF,CAAC;AACD,SAAO,CAAC,QAAQ,UAAU;AAC5B;;;ACjDA,IAAM,+BAAN,MAAuE;AAAA,EAIrE,YACU,aACR;AADQ;AAER,UAAM,SAAS,iBAAiB;AAAA,MAC9B,OAAO,CAAC,MAAM;AACZ,aAAK,sBAAsB;AAAA,MAC7B;AAAA,IACF,CAAC;AACD,SAAK,aAAa,OAAO;AAAA,MACvB,IAAI,eAAe;AAAA,QACjB,OAAO,CAAC,UAAU;AAChB,kBAAQ,MAAM,MAAM;AAAA,YAClB,KAAK;AACH,mBAAK,YAAY,QAAQ,KAAK;AAC9B;AAAA,YAEF,KAAK;AACH,mBAAK,YAAY,QAAQ;AAAA,gBACvB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,cACT,CAAC;AACD;AAAA,YAEF;AACE,oBAAM,IAAI,MAAM,0BAA0B,MAAM,IAAI,EAAE;AAAA,UAC1D;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAhCQ,YAAY;AAAA,EAEZ;AAAA,EAgCR,IAAI,WAAW;AACb,WAAO,KAAK;AAAA,EACd;AAAA,EAEQ;AAAA,EAER,YAAY,UAA+C;AACzD,SAAK,YAAY,QAAQ;AAAA,MACvB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,MACP,UAAU,SAAS;AAAA,MACnB,QAAQ,SAAS;AAAA,MACjB,SAAS,SAAS,WAAW;AAAA,IAC/B,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAQ;AACZ,QAAI,KAAK,UAAW;AAEpB,SAAK,YAAY;AACjB,SAAK,oBAAoB,MAAM;AAC/B,UAAM,KAAK;AAEX,SAAK,YAAY,QAAQ;AAAA,MACvB,MAAM;AAAA,MACN,MAAM,CAAC;AAAA,IACT,CAAC;AACD,SAAK,YAAY,MAAM;AAAA,EACzB;AACF;AAEO,IAAM,uBAAuB,CAClC,aACoB;AACpB,SAAO,IAAI,eAAe;AAAA,IACxB,MAAM,GAAG;AACP,aAAO,SAAS,QAAQ,IAAI,6BAA6B,CAAC,CAAC;AAAA,IAC7D;AAAA,IACA,KAAK,GAAG;AACN,aAAO,SAAS,OAAO,IAAI,6BAA6B,CAAC,CAAC;AAAA,IAC5D;AAAA,IACA,OAAO,GAAG;AACR,aAAO,SAAS,SAAS,CAAC;AAAA,IAC5B;AAAA,EACF,CAAC;AACH;AAEO,IAAM,iCAAiC,MAAM;AAClD,MAAI;AACJ,QAAM,SAAS,qBAAqB;AAAA,IAClC,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,EACF,CAAC;AACD,SAAO,CAAC,QAAQ,UAAU;AAC5B;;;ACxGO,IAAM,UAAN,MAAc;AAAA,EACZ,QAAQ;AAAA,EAEf,KAAK;AACH,WAAO,EAAE,KAAK;AAAA,EAChB;AACF;;;ACHO,IAAM,oBAAN,cAAgC,gBAGrC;AAAA,EACA,YAAY,KAAa;AACvB,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAC3B,mBAAW,QAAQ;AAAA,UACjB,GAAG;AAAA,UACH,MAAM,CAAC,KAAK,GAAG,MAAM,IAAI;AAAA,QAC3B,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,oBAAN,cAAgC,gBAGrC;AAAA,EACA,YAAY,KAAa;AACvB,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAC3B,cAAM;AAAA,UACJ,MAAM,CAAC,MAAM,GAAG,IAAI;AAAA,QACtB,IAAI;AAEJ,YAAI,QAAQ;AACV,gBAAM,IAAI,MAAM,2BAA2B,GAAG,SAAS,IAAI,EAAE;AAE/D,mBAAW,QAAQ;AAAA,UACjB,GAAG;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,mBAAN,cAA+B,gBAGpC;AAAA,EACA,YAAY,SAAkB;AAC5B,UAAM,eAAe,IAAI,QAAQ;AACjC,UAAM,UAAU,oBAAI,IAAoB;AACxC,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAC3B,YAAI,MAAM,SAAS,gBAAgB,MAAM,KAAK,WAAW,GAAG;AAC1D,kBAAQ,IAAI,aAAa,GAAG,GAAG,QAAQ,GAAG,CAAC;AAAA,QAC7C;AAEA,cAAM,CAAC,KAAK,GAAG,IAAI,IAAI,MAAM;AAC7B,YAAI,QAAQ,QAAW;AACrB,qBAAW,QAAQ,KAAK;AACxB;AAAA,QACF;AACA,cAAM,YAAY,QAAQ,IAAI,GAAG;AACjC,YAAI,cAAc,OAAW,OAAM,IAAI,MAAM,gBAAgB;AAE7D,mBAAW,QAAQ;AAAA,UACjB,GAAG;AAAA,UACH,MAAM,CAAC,WAAW,GAAG,IAAI;AAAA,QAC3B,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AC7CO,IAAM,2BAAN,cAA0C,gBAG/C;AAAA,EACA,YACE,aACA,kBACA,kBACA;AACA,UAAM,CAAC,QAAQ,aAAa,IAAI,gCAAgC;AAEhE,QAAI;AACJ;AAAA,MACE;AAAA,QACE,MAAM,YAAY;AAChB,wBAAc,OACX;AAAA,YACC,IAAI,eAAe;AAAA,cACjB,MAAM,OAAO;AACX,2BAAW,QAAQ,KAAK;AAAA,cAC1B;AAAA,cACA,MAAM,QAAc;AAClB,2BAAW,MAAM,MAAM;AAAA,cACzB;AAAA,cACA,QAAQ;AACN,2BAAW,UAAU;AAAA,cACvB;AAAA,YACF,CAAC;AAAA,UACH,EACC,MAAM,CAAC,UAAU;AAChB,uBAAW,MAAM,KAAK;AAAA,UACxB,CAAC;AAEH,iBAAO,YAAY,QAAQ,aAAa;AAAA,QAC1C;AAAA,QACA,UAAU,OAAO;AACf,iBAAO,YAAY,YAAY,OAAO,aAAa;AAAA,QACrD;AAAA,QACA,MAAM,QAAQ;AACZ,gBAAM,YAAY,QAAQ,aAAa;AACvC,wBAAc,MAAM;AACpB,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ACzEO,IAAM,0BAAN,cAA4C,gBAAsB;AAAA,EACvE,YAAY,WAA+D;AACzE,UAAM;AACN,UAAM,WAAW,UAAU,MAAM,QAAwC;AACzE,WAAO,eAAe,MAAM,YAAY;AAAA,MACtC,OAAO;AAAA,MACP,UAAU;AAAA,IACZ,CAAC;AAAA,EACH;AACF;;;ACTO,IAAM,oBAAN,cAAgC,gBAAgC;AAAA,EAC7D,SAAS;AAAA,EAEjB,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW,CAAC,OAAO,eAAe;AAChC,aAAK,UAAU;AACf,cAAM,QAAQ,KAAK,OAAO,MAAM,IAAI;AAGpC,iBAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AACzC,qBAAW,QAAQ,MAAM,CAAC,CAAC;AAAA,QAC7B;AAGA,aAAK,SAAS,MAAM,MAAM,SAAS,CAAC,KAAK;AAAA,MAC3C;AAAA,MACA,OAAO,CAAC,eAAe;AAErB,YAAI,KAAK,QAAQ;AACf,qBAAW,QAAQ,KAAK,MAAM;AAAA,QAChC;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;ACvBO,IAAM,yBAAN,cAAqC,gBAG1C;AAAA,EACA,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW,CAAC,OAAO,eAAe;AAChC,mBAAW,QAAQ,GAAG,MAAM,IAAI,IAAI,KAAK,UAAU,MAAM,KAAK,CAAC;AAAA,CAAI;AAAA,MACrE;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAEO,IAAM,yBAAN,cAAqC,gBAG1C;AAAA,EACA,cAAc;AACZ,UAAM;AAAA,MACJ,WAAW,CAAC,OAAO,eAAe;AAChC,cAAM,QAAQ,MAAM,QAAQ,GAAG;AAC/B,YAAI,UAAU,GAAI,OAAM,IAAI,MAAM,qBAAqB;AACvD,mBAAW,QAAQ;AAAA,UACjB,MAAM,MAAM,MAAM,GAAG,KAAK;AAAA,UAC1B,OAAO,KAAK,MAAM,MAAM,MAAM,QAAQ,CAAC,CAAC;AAAA,QAC1C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;ACVO,IAAM,+BAAN,cAA2C,gBAGhD;AAAA,EACA,cAAc;AAEZ,UAAM,QAAoB,CAAC;AAE3B,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAE3B,YAAI,MAAM,SAAS,cAAc;AAC/B,cAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,uBAAW,MAAM,IAAI,MAAM,gCAAgC,CAAC;AAC5D;AAAA,UACF;AACA,gBAAM,KAAK,MAAM,IAAI;AACrB,qBAAW,QAAQ,KAAK;AACxB;AAAA,QACF;AAGA,YACE,MAAM,SAAS,gBACf,MAAM,SAAS,YACf,MAAM,SAAS,iBACf,MAAM,SAAS,8BACf;AACA,cAAI,MAAM,KAAK,WAAW,GAAG;AAC3B,uBAAW;AAAA,cACT,IAAI,MAAM,GAAG,MAAM,IAAI,sCAAsC;AAAA,YAC/D;AACA;AAAA,UACF;AACA,gBAAM,MAAM,MAAM,KAAK,CAAC;AACxB,cAAI,MAAM,KAAK,OAAO,MAAM,QAAQ;AAClC,uBAAW,MAAM,IAAI,MAAM,uBAAuB,GAAG,EAAE,CAAC;AACxD;AAAA,UACF;AACA,gBAAM,OAAO,MAAM,GAAG;AAEtB,qBAAW,QAAQ;AAAA,YACjB,GAAG;AAAA,YACH,MAAM;AAAA;AAAA,UACR,CAAC;AACD;AAAA,QACF;AAEA,mBAAW,QAAQ,KAAK;AAAA,MAC1B;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;ACxDO,IAAM,oBAAN,cACG,wBAEV;AAAA,EACE,UAAU,IAAI,QAAQ;AAAA,IACpB,gBAAgB;AAAA,IAChB,2BAA2B;AAAA,EAC7B,CAAC;AAAA,EAED,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,gBAGpB;AAAA,QACA,UAAU,OAAO,YAAY;AAC3B,gBAAM,OAAO,MAAM;AACnB,kBAAQ,MAAM;AAAA,YACZ,KAAK,cAAc;AACjB,oBAAM,OAAO,MAAM;AACnB,kBAAI,KAAK,SAAS,aAAa;AAC7B,sBAAM,EAAE,MAAAC,OAAM,GAAG,MAAM,IAAI;AAC3B,2BAAW,QAAQ;AAAA,kBACjB;AAAA,kBACA;AAAA,gBACF,CAAC;AAAA,cACH;AACA,kBAAI,KAAK,SAAS,UAAU;AAC1B,sBAAM,EAAE,MAAAA,OAAM,GAAG,MAAM,IAAI;AAC3B,2BAAW,QAAQ;AAAA,kBACjB;AAAA,kBACA;AAAA,gBACF,CAAC;AAAA,cACH;AACA;AAAA,YACF;AAAA,YACA,KAAK,cAAc;AACjB,oBAAM,OAAO,MAAM;AACnB,sBAAQ,KAAK,MAAM;AAAA,gBACjB,KAAK,QAAQ;AACX,6BAAW,QAAQ;AAAA,oBACjB;AAAA,oBACA,OAAO,MAAM;AAAA,kBACf,CAAC;AACD;AAAA,gBACF;AAAA,gBACA,KAAK,aAAa;AAChB,6BAAW,QAAQ;AAAA,oBACjB;AAAA,oBACA,OAAO,MAAM;AAAA,kBACf,CAAC;AACD;AAAA,gBACF;AAAA,gBACA,KAAK,aAAa;AAChB,6BAAW,QAAQ;AAAA,oBACjB;AAAA,oBACA,OAAO;AAAA,sBACL,YAAY,KAAK;AAAA,sBACjB,eAAe,MAAM;AAAA,oBACvB;AAAA,kBACF,CAAC;AACD;AAAA,gBACF;AAAA,gBACA;AACE,wBAAM,IAAI;AAAA,oBACR,yCAAyC,KAAK,IAAI;AAAA,kBACpD;AAAA,cACJ;AACA;AAAA,YACF;AAAA,YACA,KAAK,UAAU;AAEb,oBAAM,OAAO,MAAM;AACnB,kBAAI,KAAK,SAAS,aAAa;AAC7B,sBAAM,IAAI;AAAA,kBACR,qDAAqD,KAAK,IAAI;AAAA,gBAChE;AAAA,cACF;AACA,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA,OAAO;AAAA,kBACL,YAAY,KAAK;AAAA,kBACjB,QAAQ,MAAM;AAAA,kBACd,UAAU,MAAM;AAAA,kBAChB,GAAI,MAAM,UAAU,EAAE,SAAS,MAAM,QAAQ,IAAI,CAAC;AAAA,gBACpD;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,cAAc;AACjB,oBAAM,EAAE,MAAAA,OAAM,GAAG,MAAM,IAAI;AAC3B,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,eAAe;AAClB,oBAAM,EAAE,MAAAA,OAAM,GAAG,MAAM,IAAI;AAC3B,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,kBAAkB;AACrB,oBAAM,EAAE,MAAAA,OAAM,GAAG,MAAM,IAAI;AAC3B,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,SAAS;AACZ,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA,OAAO,MAAM;AAAA,cACf,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,eAAe;AAClB,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA,OAAO,MAAM;AAAA,cACf,CAAC;AACD;AAAA,YACF;AAAA,YACA,KAAK,QAAQ;AACX,yBAAW,QAAQ;AAAA,gBACjB;AAAA,gBACA,OAAO,MAAM;AAAA,cACf,CAAC;AACD;AAAA,YACF;AAAA;AAAA;AAAA,YAIA,KAAK;AAAA,YACL,KAAK;AACH;AAAA,YAEF,SAAS;AACP,oBAAM,kBAAyB;AAC/B,oBAAM,IAAI,MAAM,2BAA2B,eAAe,EAAE;AAAA,YAC9D;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,IAAI,6BAA6B,CAAC,EAC9C,YAAY,SAAS,EACrB,YAAY,IAAI,uBAAuB,CAAC,EACxC,YAAY,IAAI,kBAAkB,CAAC;AAAA,IACxC,CAAC;AAAA,EACH;AACF;AAEA,IAAM,gCAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAStC;AAEO,IAAM,oBAAN,cAAgC,wBAGrC;AAAA,EACA,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,sBAAsB,oBAAI,IAAsC;AACtE,UAAI;AACJ,YAAM,YAAY,IAAI,yBAA0C;AAAA,QAC9D,UAAU,OAAO,YAAY;AAC3B,gBAAM,EAAE,MAAM,MAAM,IAAI;AAExB,cAAI,8BAA8B,SAAS,IAAI,GAAG;AAChD,oCAAwB,MAAM;AAC9B,qCAAyB;AAAA,UAC3B;AAEA,kBAAQ,MAAM;AAAA,YACZ;AACE,yBAAW,gBAAgB,KAAK;AAChC;AAAA,YAEF;AACE,yBAAW,WAAW,KAAK;AAC3B;AAAA,YAEF,8BAA8C;AAC5C,oBAAM,EAAE,YAAY,SAAS,IAAI;AACjC,oBAAM,qBAAqB,WAAW,gBAAgB;AAAA,gBACpD;AAAA,gBACA;AAAA,cACF,CAAC;AACD,kCAAoB,IAAI,YAAY,kBAAkB;AAEtD,uCAAyB,mBAAmB;AAC5C;AAAA,YACF;AAAA,YAEA,sCAAsD;AACpD,oBAAM,EAAE,YAAY,cAAc,IAAI;AACtC,oBAAM,qBAAqB,oBAAoB,IAAI,UAAU;AAC7D,kBAAI,CAAC;AACH,sBAAM,IAAI;AAAA,kBACR,4CAA4C;AAAA,gBAC9C;AACF,iCAAmB,SAAS,OAAO,aAAa;AAChD;AAAA,YACF;AAAA,YAEA,+BAA+C;AAC7C,oBAAM,EAAE,YAAY,UAAU,QAAQ,QAAQ,IAAI;AAClD,oBAAM,qBAAqB,oBAAoB,IAAI,UAAU;AAC7D,kBAAI,CAAC;AACH,sBAAM,IAAI;AAAA,kBACR,mDAAmD;AAAA,gBACrD;AACF,iCAAmB,YAAY;AAAA,gBAC7B;AAAA,gBACA;AAAA,gBACA;AAAA,cACF,CAAC;AACD;AAAA,YACF;AAAA,YAEA,yBAAyC;AACvC,oBAAM,EAAE,YAAY,UAAU,KAAK,IAAI;AAEvC,kBAAI,qBAAqB,oBAAoB,IAAI,UAAU;AAC3D,kBAAI,oBAAoB;AACtB,mCAAmB,SAAS,MAAM;AAAA,cACpC,OAAO;AACL,qCAAqB,WAAW,gBAAgB;AAAA,kBAC9C;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF,CAAC;AACD,oCAAoB,IAAI,YAAY,kBAAkB;AAAA,cACxD;AACA;AAAA,YACF;AAAA,YAEA;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,GAAG;AAAA,cACL,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,GAAG;AAAA,cACL,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,GAAG;AAAA,cACL,CAAC;AACD;AAAA,YACF;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,MAAM;AAAA,cACR,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,aAAa;AAAA,cACf,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,aAAa;AAAA,gBACtB,MAAM;AAAA,gBACN,GAAG;AAAA,cACL,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN,MAAM,CAAC;AAAA,gBACP,OAAO;AAAA,cACT,CAAC;AACD;AAAA,YAEF;AACE,yBAAW,WAAW;AAAA,gBACpB,MAAM;AAAA,gBACN,GAAG;AAAA,cACL,CAAC;AACD;AAAA,YAEF;AAAA,YACA;AAEE;AAAA,YAEF,SAAS;AACP,oBAAM,kBAAyB;AAC/B,oBAAM,IAAI,MAAM,2BAA2B,eAAe,EAAE;AAAA,YAC9D;AAAA,UACF;AAAA,QACF;AAAA,QACA,QAAQ;AACN,kCAAwB,MAAM;AAC9B,mCAAyB;AACzB,8BAAoB,QAAQ,CAAC,eAAe,WAAW,MAAM,CAAC;AAC9D,8BAAoB,MAAM;AAAA,QAC5B;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,uBAAuB,CAAC,EACxC,YAAY,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;;;AClWA,wBAA+B;AAExB,IAAM,iBAAa;AAAA,EACxB;AAAA,EACA;AACF;;;ACsCA,IAAM,gCAAN,MAAyE;AAAA,EAC/D,UAAU,kBAAkB;AAAA,EAC5B;AAAA,EAMA,kBAAkB,IAAI,QAAQ;AAAA,EAEtC,IAAI,sBAAsB;AACxB,WAAO,KAAK,QAAQ,SAAS;AAAA,EAC/B;AAAA,EAEA,yBAAyB;AACvB,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EAEQ;AAAA,EACR,4BAA4B,UAAsB;AAChD,SAAK,mBAAmB;AAAA,EAC1B;AAAA,EAEQ,SAAS,MAAgB,QAAyB;AACxD,QAAI,KAAK,SAAS;AAChB,WAAK,QAAQ,WAAW,MAAM;AAC9B,WAAK,UAAU;AAAA,IACjB;AAEA,SAAK,QAAQ;AAAA,MACX,MAAM;AAAA,MACN;AAAA,MACA,MAAM,CAAC;AAAA,IACT,CAAC;AACD,SAAK,QAAQ;AAAA,MACX,OAAO,YAAY,IAAI,kBAAkB,KAAK,gBAAgB,KAAK,CAAC;AAAA,IACtE;AAAA,EACF;AAAA,EAEA,MAAM,QAAyB;AAC7B,SAAK,QAAQ;AAAA,MACX,OAAO,YAAY,IAAI,iBAAiB,KAAK,eAAe,CAAC;AAAA,IAC/D;AAAA,EACF;AAAA,EAEA,WAAW,WAAmB;AAC5B,QAAI,KAAK,SAAS,SAAS,QAAQ;AACjC,WAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN,YAAY,KAAK,YAAY;AAAA,MAC/B;AAAA,IACF;AACA,SAAK,QAAQ,WAAW,OAAO,SAAS;AAAA,EAC1C;AAAA,EAEA,gBAAgB,WAAmB;AACjC,QAAI,KAAK,SAAS,SAAS,aAAa;AACtC,WAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN,YAAY,KAAK,iBAAiB;AAAA,MACpC;AAAA,IACF;AACA,SAAK,QAAQ,WAAW,OAAO,SAAS;AAAA,EAC1C;AAAA,EAEA,cAAc;AACZ,UAAM,CAAC,QAAQ,UAAU,IAAI,2BAA2B;AACxD,SAAK,SAAS,EAAE,MAAM,OAAO,GAAG,MAAM;AACtC,WAAO;AAAA,EACT;AAAA,EAEA,mBAAmB;AACjB,UAAM,CAAC,QAAQ,UAAU,IAAI,2BAA2B;AACxD,SAAK,SAAS,EAAE,MAAM,YAAY,GAAG,MAAM;AAC3C,WAAO;AAAA,EACT;AAAA,EAEA,gBACE,SAC0B;AAC1B,UAAM,MAAM,OAAO,YAAY,WAAW,EAAE,UAAU,QAAQ,IAAI;AAClE,UAAM,WAAW,IAAI;AACrB,UAAM,aAAa,IAAI,cAAc,WAAW;AAEhD,UAAM,CAAC,QAAQ,UAAU,IAAI,+BAA+B;AAC5D,SAAK,SAAS,EAAE,MAAM,aAAa,UAAU,WAAW,GAAG,MAAM;AAEjE,QAAI,IAAI,aAAa,QAAW;AAC9B,iBAAW,SAAS,OAAO,IAAI,QAAQ;AACvC,iBAAW,SAAS,MAAM;AAAA,IAC5B;AACA,QAAI,IAAI,SAAS,QAAW;AAC1B,iBAAW,SAAS,OAAO,KAAK,UAAU,IAAI,IAAI,CAAC;AACnD,iBAAW,SAAS,MAAM;AAAA,IAC5B;AACA,QAAI,IAAI,aAAa,QAAW;AAC9B,iBAAW,YAAY,IAAI,QAAQ;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,SAAqB;AAChC,SAAK;AAAA,MACH;AAAA,MACA,IAAI,eAAe;AAAA,QACjB,MAAM,YAAY;AAChB,qBAAW,QAAQ;AAAA,YACjB,MAAM;AAAA,YACN,MAAM,CAAC;AAAA,UACT,CAAC;AACD,qBAAW,MAAM;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,WAAW,SAAmB;AAC5B,SAAK;AAAA,MACH;AAAA,MACA,IAAI,eAAe;AAAA,QACjB,MAAM,YAAY;AAChB,qBAAW,QAAQ;AAAA,YACjB,MAAM;AAAA,YACN,MAAM,CAAC;AAAA,UACT,CAAC;AACD,qBAAW,MAAM;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,QAAQ,OAA6B;AACnC,SAAK,QAAQ,QAAQ,KAAK;AAE1B,QAAI,MAAM,SAAS,gBAAgB,MAAM,KAAK,WAAW,GAAG;AAC1D,WAAK,gBAAgB,GAAG;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,QAAQ;AACN,SAAK,QAAQ,KAAK;AAClB,SAAK,SAAS,YAAY,MAAM;AAEhC,SAAK,mBAAmB;AAAA,EAC1B;AACF;AAEO,SAAS,sBACd,UACiB;AACjB,QAAM,aAAa,IAAI,8BAA8B;AAErD,MAAI;AACJ,MAAI;AACF,oBAAgB,SAAS,UAAU;AAAA,EACrC,SAAS,GAAG;AACV,QAAI,CAAC,WAAW,qBAAqB;AACnC,iBAAW,QAAQ;AAAA,QACjB,MAAM;AAAA,QACN,MAAM,CAAC;AAAA,QACP,OAAO,OAAO,CAAC;AAAA,MACjB,CAAC;AACD,iBAAW,MAAM;AAAA,IACnB;AACA,UAAM;AAAA,EACR;AAEA,MAAI,yBAAyB,SAAS;AACpC,UAAM,UAAU,YAAY;AAC1B,UAAI;AACF,cAAM;AAAA,MACR,SAAS,GAAG;AACV,YAAI,CAAC,WAAW,qBAAqB;AACnC,qBAAW,QAAQ;AAAA,YACjB,MAAM;AAAA,YACN,MAAM,CAAC;AAAA,YACP,OAAO,OAAO,CAAC;AAAA,UACjB,CAAC;AAAA,QACH;AACA,cAAM;AAAA,MACR,UAAE;AACA,YAAI,CAAC,WAAW,qBAAqB;AACnC,qBAAW,MAAM;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AACA,YAAQ;AAAA,EACV,OAAO;AACL,QAAI,CAAC,WAAW,qBAAqB;AACnC,iBAAW,MAAM;AAAA,IACnB;AAAA,EACF;AAEA,SAAO,WAAW,uBAAuB;AAC3C;AAEA,IAAMC,wBAAuB,WAAe;AAC1C,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU,IAAI,QAAW,CAAC,KAAK,QAAQ;AAC3C,cAAU;AACV,aAAS;AAAA,EACX,CAAC;AACD,MAAI,CAAC,WAAW,CAAC,OAAQ,OAAM,IAAI,MAAM,0BAA0B;AACnE,SAAO,EAAE,SAAS,SAAS,OAAO;AACpC;AAEO,SAAS,kCAAkC;AAChD,QAAM,EAAE,SAAS,QAAQ,IAAIA,sBAA2B;AACxD,MAAI;AACJ,QAAM,SAAS,sBAAsB,CAAC,MAAM;AAC1C,iBAAa;AAEb,IAAC,WAA6C;AAAA,MAC5C;AAAA,IACF;AAEA,WAAO;AAAA,EACT,CAAC;AACD,SAAO,CAAC,QAAQ,UAAU;AAC5B;AAEO,SAAS,8BACd,UACA;AACA,SAAO,gBAAgB;AAAA,IACrB,sBAAsB,QAAQ;AAAA,IAC9B,IAAI,kBAAkB;AAAA,EACxB;AACF;;;ACjRA,+BAAkB;;;ACAX,SAAS,mBACd,UACA,aACA,cAC0B;AAC1B,MAAI;AACF,UAAM,iBAAiB,SAAS;AAChC,QACE,OAAO,mBAAmB,YAC1B,mBAAmB,QACnB,UAAU,gBACV;AACA,aAAO,eAAe,KAAK,aAAa,YAAY;AAAA,IACtD,OAAO;AACL,kBAAY,cAAc;AAAA,IAC5B;AAAA,EACF,SAAS,GAAG;AACV,iBAAa,CAAC;AAAA,EAChB;AACF;;;ADCO,IAAM,sBAAN,cAAkC,wBAGvC;AAAA,EACA,YAAY,cAA4B;AACtC,UAAM,mBAAmB,oBAAI,IAA+B;AAC5D,UAAM,mBAA2C,CAAC;AAClD,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,gBAGpB;AAAA,QACA,UAAU,OAAO,YAAY;AAE3B,cAAI,MAAM,SAAS,iBAAiB,MAAM,KAAK,SAAS,aAAa;AACnE,uBAAW,QAAQ,KAAK;AAAA,UAC1B;AAEA,gBAAM,OAAO,MAAM;AAEnB,kBAAQ,MAAM;AAAA,YACZ,KAAK,cAAc;AACjB,kBAAI,MAAM,KAAK,SAAS,aAAa;AACnC,sBAAM,aAAa,MAAM,KAAK;AAC9B,oBAAI,iBAAiB,UAAU,MAAM,QAAW;AAC9C,mCAAiB,UAAU,IAAI,MAAM;AAAA,gBACvC,OAAO;AACL,mCAAiB,UAAU,KAAK,MAAM;AAAA,gBACxC;AAAA,cACF;AACA;AAAA,YACF;AAAA,YACA,KAAK,8BAA8B;AACjC,kBAAI,MAAM,KAAK,SAAS,YAAa;AAErC,oBAAM,EAAE,YAAY,SAAS,IAAI,MAAM;AACvC,oBAAM,WAAW,iBAAiB,UAAU;AAE5C,oBAAM,UAAU;AAAA,gBACd,MAAM;AACJ,sBAAI,CAAC,UAAU;AACb,4BAAQ;AAAA,sBACN;AAAA,oBACF;AACA,0BAAM,IAAI;AAAA,sBACR;AAAA,oBACF;AAAA,kBACF;AAEA,sBAAI;AACJ,sBAAI;AACF,2BAAO,yBAAAC,QAAM,MAAM,QAAQ;AAAA,kBAC7B,SAAS,GAAG;AACV,0BAAM,IAAI;AAAA,sBACR,sCAAsC,KAAK,UAAW,EAAY,OAAO,CAAC;AAAA,oBAC5E;AAAA,kBACF;AAEA,yBAAO,aAAa;AAAA,oBAClB;AAAA,oBACA;AAAA,oBACA;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,gBACA,CAAC,MAAM;AACL,sBAAI,MAAM,OAAW;AAGrB,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,MAAM,MAAM;AAAA,oBACZ,UAAU,EAAE;AAAA,oBACZ,QAAQ,EAAE;AAAA,oBACV,SAAS,EAAE;AAAA,kBACb,CAAC;AAAA,gBACH;AAAA,gBACA,CAAC,MAAM;AACL,6BAAW,QAAQ;AAAA,oBACjB,MAAM;AAAA,oBACN,MAAM,MAAM;AAAA,oBACZ,QAAQ,OAAO,CAAC;AAAA,oBAChB,SAAS;AAAA,kBACX,CAAC;AAAA,gBACH;AAAA,cACF;AACA,kBAAI,SAAS;AACX,iCAAiB,IAAI,YAAY,OAAO;AAAA,cAC1C;AACA;AAAA,YACF;AAAA,YAEA,KAAK,eAAe;AAClB,kBAAI,MAAM,KAAK,SAAS,YAAa;AAErC,oBAAM,EAAE,WAAW,IAAI,MAAM;AAC7B,oBAAM,kBAAkB,iBAAiB,IAAI,UAAU;AACvD,kBAAI,iBAAiB;AACnB,gCAAgB,KAAK,MAAM;AACzB,6BAAW,QAAQ,KAAK;AAAA,gBAC1B,CAAC;AAAA,cACH,OAAO;AACL,2BAAW,QAAQ,KAAK;AAAA,cAC1B;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACA,MAAM,QAAQ;AACZ,gBAAM,QAAQ,IAAI,iBAAiB,OAAO,CAAC;AAAA,QAC7C;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,IAAI,6BAA6B,CAAC,EAC9C,YAAY,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;;;AExIA,IAAAC,4BAAkB;;;AC0CX,SAAS,QAAQ,OAAuB;AAC7C,QAAM,QAAiB,CAAC,MAAM;AAC9B,MAAI,iBAAiB;AACrB,MAAI,eAA8B;AAElC,WAAS,kBAAkB,MAAc,GAAW,WAAkB;AACpE;AACE,cAAQ,MAAM;AAAA,QACZ,KAAK,KAAK;AACR,2BAAiB;AACjB,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,eAAe;AAC1B;AAAA,QACF;AAAA,QAEA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,KAAK;AACR,2BAAiB;AACjB,yBAAe;AACf,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,gBAAgB;AAC3B;AAAA,QACF;AAAA,QAEA,KAAK,KAAK;AACR,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,eAAe;AAC1B;AAAA,QACF;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK,KAAK;AACR,2BAAiB;AACjB,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,eAAe;AAC1B;AAAA,QACF;AAAA,QAEA,KAAK,KAAK;AACR,2BAAiB;AACjB,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,qBAAqB;AAChC;AAAA,QACF;AAAA,QAEA,KAAK,KAAK;AACR,2BAAiB;AACjB,gBAAM,IAAI;AACV,gBAAM,KAAK,SAAS;AACpB,gBAAM,KAAK,oBAAoB;AAC/B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,wBAAwB,MAAc,GAAW;AACxD,YAAQ,MAAM;AAAA,MACZ,KAAK,KAAK;AACR,cAAM,IAAI;AACV,cAAM,KAAK,2BAA2B;AACtC;AAAA,MACF;AAAA,MACA,KAAK,KAAK;AACR,yBAAiB;AACjB,cAAM,IAAI;AACV;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,uBAAuB,MAAc,GAAW;AACvD,YAAQ,MAAM;AAAA,MACZ,KAAK,KAAK;AACR,cAAM,IAAI;AACV,cAAM,KAAK,0BAA0B;AACrC;AAAA,MACF;AAAA,MACA,KAAK,KAAK;AACR,yBAAiB;AACjB,cAAM,IAAI;AACV;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,eAAe,MAAM,MAAM,SAAS,CAAC;AAE3C,YAAQ,cAAc;AAAA,MACpB,KAAK;AACH,0BAAkB,MAAM,GAAG,QAAQ;AACnC;AAAA,MAEF,KAAK,uBAAuB;AAC1B,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,kBAAM,KAAK,mBAAmB;AAC9B;AAAA,UACF;AAAA,UACA,KAAK,KAAK;AACR,6BAAiB;AACjB,kBAAM,IAAI;AACV;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF;AAAA,MAEA,KAAK,6BAA6B;AAChC,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,kBAAM,KAAK,mBAAmB;AAC9B;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF;AAAA,MAEA,KAAK,qBAAqB;AACxB,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,kBAAM,KAAK,yBAAyB;AACpC;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF;AAAA,MAEA,KAAK,2BAA2B;AAC9B,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,kBAAM,KAAK,4BAA4B;AAEvC;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF;AAAA,MAEA,KAAK,8BAA8B;AACjC,0BAAkB,MAAM,GAAG,2BAA2B;AACtD;AAAA,MACF;AAAA,MAEA,KAAK,6BAA6B;AAChC,gCAAwB,MAAM,CAAC;AAC/B;AAAA,MACF;AAAA,MAEA,KAAK,iBAAiB;AACpB,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,6BAAiB;AACjB;AAAA,UACF;AAAA,UAEA,KAAK,MAAM;AACT,kBAAM,KAAK,sBAAsB;AACjC;AAAA,UACF;AAAA,UAEA,SAAS;AACP,6BAAiB;AAAA,UACnB;AAAA,QACF;AAEA;AAAA,MACF;AAAA,MAEA,KAAK,sBAAsB;AACzB,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,6BAAiB;AACjB,kBAAM,IAAI;AACV;AAAA,UACF;AAAA,UAEA,SAAS;AACP,6BAAiB;AACjB,8BAAkB,MAAM,GAAG,0BAA0B;AACrD;AAAA,UACF;AAAA,QACF;AACA;AAAA,MACF;AAAA,MAEA,KAAK,4BAA4B;AAC/B,gBAAQ,MAAM;AAAA,UACZ,KAAK,KAAK;AACR,kBAAM,IAAI;AACV,kBAAM,KAAK,0BAA0B;AACrC;AAAA,UACF;AAAA,UAEA,KAAK,KAAK;AACR,6BAAiB;AACjB,kBAAM,IAAI;AACV;AAAA,UACF;AAAA,UAEA,SAAS;AACP,6BAAiB;AACjB;AAAA,UACF;AAAA,QACF;AAEA;AAAA,MACF;AAAA,MAEA,KAAK,4BAA4B;AAC/B,0BAAkB,MAAM,GAAG,0BAA0B;AACrD;AAAA,MACF;AAAA,MAEA,KAAK,wBAAwB;AAC3B,cAAM,IAAI;AACV,yBAAiB;AAEjB;AAAA,MACF;AAAA,MAEA,KAAK,iBAAiB;AACpB,gBAAQ,MAAM;AAAA,UACZ,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK,KAAK;AACR,6BAAiB;AACjB;AAAA,UACF;AAAA,UAEA,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK,KAAK;AACR;AAAA,UACF;AAAA,UAEA,KAAK,KAAK;AACR,kBAAM,IAAI;AAEV,gBAAI,MAAM,MAAM,SAAS,CAAC,MAAM,4BAA4B;AAC1D,qCAAuB,MAAM,CAAC;AAAA,YAChC;AAEA,gBAAI,MAAM,MAAM,SAAS,CAAC,MAAM,6BAA6B;AAC3D,sCAAwB,MAAM,CAAC;AAAA,YACjC;AAEA;AAAA,UACF;AAAA,UAEA,KAAK,KAAK;AACR,kBAAM,IAAI;AAEV,gBAAI,MAAM,MAAM,SAAS,CAAC,MAAM,6BAA6B;AAC3D,sCAAwB,MAAM,CAAC;AAAA,YACjC;AAEA;AAAA,UACF;AAAA,UAEA,KAAK,KAAK;AACR,kBAAM,IAAI;AAEV,gBAAI,MAAM,MAAM,SAAS,CAAC,MAAM,4BAA4B;AAC1D,qCAAuB,MAAM,CAAC;AAAA,YAChC;AAEA;AAAA,UACF;AAAA,UAEA,SAAS;AACP,kBAAM,IAAI;AACV;AAAA,UACF;AAAA,QACF;AAEA;AAAA,MACF;AAAA,MAEA,KAAK,kBAAkB;AACrB,cAAM,iBAAiB,MAAM,UAAU,cAAe,IAAI,CAAC;AAE3D,YACE,CAAC,QAAQ,WAAW,cAAc,KAClC,CAAC,OAAO,WAAW,cAAc,KACjC,CAAC,OAAO,WAAW,cAAc,GACjC;AACA,gBAAM,IAAI;AAEV,cAAI,MAAM,MAAM,SAAS,CAAC,MAAM,6BAA6B;AAC3D,oCAAwB,MAAM,CAAC;AAAA,UACjC,WAAW,MAAM,MAAM,SAAS,CAAC,MAAM,4BAA4B;AACjE,mCAAuB,MAAM,CAAC;AAAA,UAChC;AAAA,QACF,OAAO;AACL,2BAAiB;AAAA,QACnB;AAEA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS,MAAM,MAAM,GAAG,iBAAiB,CAAC;AAE9C,WAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAC1C,UAAM,QAAQ,MAAM,CAAC;AAErB,YAAQ,OAAO;AAAA,MACb,KAAK,iBAAiB;AACpB,kBAAU;AACV;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,6BAA6B;AAChC,kBAAU;AACV;AAAA,MACF;AAAA,MAEA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,4BAA4B;AAC/B,kBAAU;AACV;AAAA,MACF;AAAA,MAEA,KAAK,kBAAkB;AACrB,cAAM,iBAAiB,MAAM,UAAU,cAAe,MAAM,MAAM;AAElE,YAAI,OAAO,WAAW,cAAc,GAAG;AACrC,oBAAU,OAAO,MAAM,eAAe,MAAM;AAAA,QAC9C,WAAW,QAAQ,WAAW,cAAc,GAAG;AAC7C,oBAAU,QAAQ,MAAM,eAAe,MAAM;AAAA,QAC/C,WAAW,OAAO,WAAW,cAAc,GAAG;AAC5C,oBAAU,OAAO,MAAM,eAAe,MAAM;AAAA,QAC9C;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;AD7ZO,IAAM,mBAAmB,CAAC,SAAiB;AAChD,MAAI;AACF,WAAO,0BAAAC,QAAM,MAAM,IAAI;AAAA,EACzB,QAAQ;AACN,QAAI;AACF,aAAO,0BAAAA,QAAM,MAAM,QAAQ,IAAI,CAAC;AAAA,IAClC,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AEEA,IAAM,uBAAuB,OAAyB;AAAA,EACpD,MAAM;AAAA,EACN,QAAQ,EAAE,MAAM,UAAU;AAAA,EAC1B,OAAO,CAAC;AAAA,EACR,IAAI,UAAU;AACZ,WAAO,KAAK;AAAA,EACd;AAAA,EACA,UAAU;AAAA,IACR,eAAe,CAAC;AAAA,IAChB,sBAAsB,CAAC;AAAA,IACvB,OAAO,CAAC;AAAA,IACR,QAAQ,CAAC;AAAA,EACX;AACF;AAEA,IAAM,oBAAoB,CACxB,SACA,OACA,YACqB;AACrB,MAAI,QAAQ,MAAM,WAAW,GAAG;AAC9B,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAEA,MAAI,MAAM,KAAK,WAAW;AACxB,UAAM,IAAI,MAAM,qCAAqC;AAEvD,QAAM,YAAY,MAAM,KAAK,CAAC;AAC9B,QAAM,cAAc,QAAQ,QAAQ,MAAM,SAAS,CAAE;AACrD,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO;AAAA,MACL,GAAG,QAAQ,MAAM,MAAM,GAAG,SAAS;AAAA,MACnC;AAAA,MACA,GAAG,QAAQ,MAAM,MAAM,YAAY,CAAC;AAAA,IACtC;AAAA,IACA,IAAI,UAAU;AACZ,aAAO,KAAK;AAAA,IACd;AAAA,EACF;AACF;AAEA,IAAM,kBAAkB,CACtB,SACA,UACqB;AACrB,QAAM,WAAW,MAAM;AACvB,MAAI,SAAS,SAAS,UAAU,SAAS,SAAS,aAAa;AAC7D,UAAM,cAAwC;AAAA,MAC5C,MAAM,SAAS;AAAA,MACf,MAAM;AAAA,MACN,QAAQ,EAAE,MAAM,UAAU;AAAA,IAC5B;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO,CAAC,GAAG,QAAQ,OAAO,WAAW;AAAA,MACrC,IAAI,UAAU;AACZ,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF,WAAW,SAAS,SAAS,aAAa;AACxC,UAAM,kBAAgC;AAAA,MACpC,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ,EAAE,MAAM,WAAW,gBAAgB,MAAM;AAAA,MACjD,YAAY,SAAS;AAAA,MACrB,UAAU,SAAS;AAAA,MACnB,UAAU;AAAA,MACV,MAAM,CAAC;AAAA,IACT;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO,CAAC,GAAG,QAAQ,OAAO,eAAe;AAAA,MACzC,IAAI,UAAU;AACZ,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF,WAAW,SAAS,SAAS,UAAU;AACrC,UAAM,gBAA4B;AAAA,MAChC,MAAM;AAAA,MACN,YAAY,SAAS;AAAA,MACrB,IAAI,SAAS;AAAA,MACb,KAAK,SAAS;AAAA,MACd,GAAI,SAAS,QAAQ,EAAE,OAAO,SAAS,MAAM,IAAI;AAAA,IACnD;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO,CAAC,GAAG,QAAQ,OAAO,aAAa;AAAA,MACvC,IAAI,UAAU;AACZ,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF,WAAW,SAAS,SAAS,QAAQ;AACnC,UAAM,cAAwB;AAAA,MAC5B,MAAM;AAAA,MACN,UAAU,SAAS;AAAA,MACnB,MAAM,SAAS;AAAA,IACjB;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO,CAAC,GAAG,QAAQ,OAAO,WAAW;AAAA,MACrC,IAAI,UAAU;AACZ,eAAO,KAAK;AAAA,MACd;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,0BAA0B,SAAS,IAAI,EAAE;AAAA,EAC3D;AACF;AAEA,IAAM,+BAA+B,CACnC,SACA,UAGqB;AACrB,SAAO,kBAAkB,SAAS,OAAO,CAAC,SAAS;AACjD,QAAI,KAAK,SAAS,aAAa;AAC7B,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AACA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AAEA,IAAM,mBAAmB,CACvB,SACA,UACqB;AACrB,SAAO,kBAAkB,SAAS,OAAO,CAAC,UAAU;AAAA,IAClD,GAAG;AAAA,IACH,QAAQ,EAAE,MAAM,YAAY,QAAQ,UAAU;AAAA,EAChD,EAAE;AACJ;AAEA,IAAM,kBAAkB,CACtB,SACA,UACqB;AACrB,SAAO,kBAAkB,SAAS,OAAO,CAAC,SAAS;AACjD,QAAI,KAAK,SAAS,QAAQ;AACxB,aAAO,EAAE,GAAG,MAAM,MAAM,KAAK,OAAO,MAAM,UAAU;AAAA,IACtD,WAAW,KAAK,SAAS,aAAa;AACpC,YAAM,cAAc,KAAK,WAAW,MAAM;AAC1C,UAAI;AACJ,UAAI;AACF,kBAAU,iBAAiB,WAAW;AAAA,MACxC,SAAS,KAAK;AACZ,kBAAU,KAAK;AAAA,MACjB;AACA,aAAO,EAAE,GAAG,MAAM,UAAU,aAAa,MAAM,QAAQ;AAAA,IACzD,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAEA,IAAM,eAAe,CACnB,SACA,UACqB;AACrB,SAAO,kBAAkB,SAAS,OAAO,CAAC,SAAS;AACjD,QAAI,KAAK,SAAS,aAAa;AAC7B,aAAO;AAAA,QACL,GAAG;AAAA,QACH,OAAO;AAAA,QACP,UAAU,MAAM;AAAA,QAChB,QAAQ,MAAM;AAAA,QACd,SAAS,MAAM,WAAW;AAAA,QAC1B,QAAQ,EAAE,MAAM,YAAY,QAAQ,OAAO;AAAA,MAC7C;AAAA,IACF,OAAO;AACL,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AAAA,EACF,CAAC;AACH;AAEA,IAAM,sBAAsB,CAC1B,SACA,UACqB;AACrB,QAAM,YAAY,UAAU,KAAK;AACjC,SAAO,EAAE,GAAG,SAAS,QAAQ,UAAU;AACzC;AAEA,IAAM,YAAY,CAChB,UAG2B;AAC3B,MAAI,MAAM,iBAAiB,cAAc;AACvC,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,IACV;AAAA,EACF,WACE,MAAM,iBAAiB,UACvB,MAAM,iBAAiB,WACvB;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,MAAM;AAAA,IAChB;AAAA,EACF,OAAO;AACL,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,MAAM;AAAA,IAChB;AAAA,EACF;AACF;AAEA,IAAM,oBAAoB,CACxB,SACA,UACqB;AACrB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,QAAQ;AAAA,MACX,sBAAsB;AAAA,QACpB,GAAG,QAAQ,SAAS;AAAA,QACpB,GAAG,MAAM;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,aAAa,CACjB,SACA,UACqB;AACrB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,QAAQ;AAAA,MACX,eAAe,CAAC,GAAG,QAAQ,SAAS,eAAe,GAAG,MAAM,IAAI;AAAA,IAClE;AAAA,EACF;AACF;AAEA,IAAM,kBAAkB,CACtB,SACA,UACqB;AACrB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,QAAQ;AAAA,MACX,OAAO;AAAA,QACL,GAAG,QAAQ,SAAS;AAAA,QACpB,EAAE,OAAO,WAAW,WAAW,MAAM,UAAU;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,mBAAmB,CACvB,SACA,UACqB;AACrB,QAAM,QAAQ,QAAQ,SAAS,MAAM,MAAM;AAC3C,QAAM,YAAY,MAAM,SAAS;AAGjC,MAAI,MAAM,SAAS,KAAK,MAAM,SAAS,GAAG,UAAU,WAAW;AAC7D,UAAM,SAAS,IAAI;AAAA,MACjB,GAAG,MAAM,SAAS;AAAA,MAClB,OAAO;AAAA,MACP,cAAc,MAAM;AAAA,MACpB,OAAO,MAAM;AAAA,MACb,aAAa,MAAM;AAAA,IACrB;AAAA,EACF,OAAO;AAEL,UAAM,KAAK;AAAA,MACT,OAAO;AAAA,MACP,WAAW,WAAW;AAAA,MACtB,cAAc,MAAM;AAAA,MACpB,OAAO,MAAM;AAAA,MACb,aAAa,MAAM;AAAA,IACrB,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU;AAAA,MACR,GAAG,QAAQ;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAEA,IAAM,mBAAmB,CACvB,SACA,UACqB;AACrB,SAAO;AAAA,IACL,GAAG;AAAA,IACH,QAAQ,EAAE,MAAM,cAAc,QAAQ,SAAS,OAAO,MAAM,MAAM;AAAA,EACpE;AACF;AAEO,IAAM,8BAAN,cAA0C,gBAG/C;AAAA,EACA,YAAY;AAAA,IACV;AAAA,EACF,IAEI,CAAC,GAAG;AACN,QAAI,UAAU,kBAAkB,qBAAqB;AACrD,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAC3B,cAAM,OAAO,MAAM;AACnB,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,sBAAU,gBAAgB,SAAS,KAAK;AACxC;AAAA,UAEF,KAAK;AACH,sBAAU,6BAA6B,SAAS,KAAK;AACrD;AAAA,UAEF,KAAK;AACH,sBAAU,iBAAiB,SAAS,KAAK;AACzC;AAAA,UAEF,KAAK;AACH,sBAAU,gBAAgB,SAAS,KAAK;AACxC;AAAA,UACF,KAAK;AACH,sBAAU,aAAa,SAAS,KAAK;AACrC;AAAA,UACF,KAAK;AACH,sBAAU,oBAAoB,SAAS,KAAK;AAC5C;AAAA,UACF,KAAK;AACH,sBAAU,kBAAkB,SAAS,KAAK;AAC1C;AAAA,UACF,KAAK;AACH,sBAAU,WAAW,SAAS,KAAK;AACnC;AAAA,UACF,KAAK;AACH,sBAAU,gBAAgB,SAAS,KAAK;AACxC;AAAA,UACF,KAAK;AACH,sBAAU,iBAAiB,SAAS,KAAK;AACzC;AAAA,UACF,KAAK;AACH,sBAAU,iBAAiB,SAAS,KAAK;AACzC;AAAA,UACF,SAAS;AACP,kBAAM,gBAAuB;AAC7B,kBAAM,IAAI,MAAM,2BAA2B,aAAa,EAAE;AAAA,UAC5D;AAAA,QACF;AACA,mBAAW,QAAQ,OAAO;AAAA,MAC5B;AAAA,MACA,MAAM,YAAY;AAChB,YAAI,QAAQ,QAAQ,SAAS,WAAW;AAEtC,gBAAM,iBAAiB,QAAQ,OAAO,GAAG,EAAE,GAAG,SAAS;AACvD,oBAAU,oBAAoB,SAAS;AAAA,YACrC,MAAM;AAAA,YACN,MAAM,CAAC;AAAA,YACP,cAAc,iBAAiB,eAAe;AAAA,YAC9C,OAAO;AAAA,cACL,cAAc;AAAA,cACd,kBAAkB;AAAA,YACpB;AAAA,UACF,CAAC;AACD,qBAAW,QAAQ,OAAO;AAAA,QAC5B;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;ACvYO,IAAM,mBAAN,cACG,wBAEV;AAAA,EACE,UAAU,IAAI,QAAQ;AAAA,IACpB,gBAAgB;AAAA,IAChB,2BAA2B;AAAA,EAC7B,CAAC;AAAA,EAED,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,gBAA8C;AAAA,QAClE,UAAU,OAAO,YAAY;AAC3B,gBAAM,OAAO,MAAM;AACnB,kBAAQ,MAAM;AAAA,YACZ,KAAK;AACH,yBAAW,QAAQ,MAAM,SAAS;AAClC;AAAA,YAEF;AACE,oBAAM,kBAYQ;AACd,oBAAM,IAAI,MAAM,2BAA2B,eAAe,EAAE;AAAA,UAChE;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,SAAS,EACrB,YAAY,IAAI,kBAAkB,CAAC;AAAA,IACxC,CAAC;AAAA,EACH;AACF;AAEO,IAAM,mBAAN,cAA+B,wBAGpC;AAAA,EACA,cAAc;AACZ,UAAM,CAAC,aAAa;AAClB,YAAM,YAAY,IAAI,yBAAiC;AAAA,QACrD,UAAU,OAAO,YAAY;AAC3B,qBAAW,WAAW,KAAK;AAAA,QAC7B;AAAA,MACF,CAAC;AAED,aAAO,SACJ,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,SAAS;AAAA,IAC1B,CAAC;AAAA,EACH;AACF;;;AC/DO,IAAM,yBAAN,MAAM,wBAAuB;AAAA,EAClC,YAA4B,UAA4C;AAA5C;AAC1B,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,OAAO,oBAAoB,QAAyB;AAClD,WAAO,IAAI;AAAA,MACT,OAAO,YAAY,IAAI,4BAA4B,CAAC;AAAA,IACtD;AAAA,EACF;AAAA,EAEA,MAAM,kBAA6C;AACjD,QAAI;AACJ,qBAAiB,SAAS,MAAM;AAC9B,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,QACL,MAAM;AAAA,QACN,QAAQ,EAAE,MAAM,YAAY,QAAQ,UAAU;AAAA,QAC9C,OAAO,CAAC;AAAA,QACR,SAAS,CAAC;AAAA,QACV,UAAU;AAAA,UACR,eAAe,CAAC;AAAA,UAChB,sBAAsB,CAAC;AAAA,UACvB,OAAO,CAAC;AAAA,UACR,QAAQ,CAAC;AAAA,QACX;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,CAAC,OAAO,aAAa,IAAI;AACvB,UAAM,SAAS,KAAK,SAAS,UAAU;AACvC,WAAO;AAAA,MACL,MAAM,OAA6D;AACjE,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,eAAO,OAAO,EAAE,MAAM,MAAM,OAAO,OAAU,IAAI,EAAE,MAAM,OAAO,MAAM;AAAA,MACxE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAwD;AACtD,UAAM,CAAC,WAAW,SAAS,IAAI,KAAK,SAAS,IAAI;AACjD,WAAO;AAAA,MACL,IAAI,wBAAuB,SAAS;AAAA,MACpC,IAAI,wBAAuB,SAAS;AAAA,IACtC;AAAA,EACF;AACF;;;ACrDA,IAAM,uBAAuB,OAAO,IAAI,mBAAmB;AAQpD,IAAM,eAAN,MAA4B;AAAA,EACjC,KAAK,oBAAoB,IAAI;AAC3B,WAAO;AAAA,EACT;AAAA,EAES;AAAA,EACA;AAAA,EACA;AAAA,EAET,YAAY,SAAoC;AAC9C,SAAK,WAAW,QAAQ;AACxB,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ,WAAW;AAAA,EACpC;AAAA,EAEA,QAAQ,OAAO,WAAW,EAAE,KAA4C;AACtE,WACE,OAAO,QAAQ,YAAY,QAAQ,QAAQ,wBAAwB;AAAA,EAEvE;AACF;","names":["item","type","promiseWithResolvers","sjson","import_secure_json_parse","sjson"]}