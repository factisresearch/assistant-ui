{"version":3,"sources":["../src/ai-sdk/index.ts","../src/ai-sdk/language-model.ts"],"sourcesContent":["import type { TextStreamPart, ObjectStreamPart, Tool } from \"ai\";\nimport { AssistantStream } from \"../core/AssistantStream\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\nimport { ReadonlyJSONValue } from \"../core/utils/json/json-value\";\n\nexport const fromStreamText = (\n  stream: ReadableStream<TextStreamPart<Record<string, Tool>>>,\n): AssistantStream => {\n  const toolControllers = new Map<string, ToolCallStreamController>();\n  let currentToolCallArgsText: ToolCallStreamController | undefined;\n\n  const endCurrentToolCallArgsText = () => {\n    if (!currentToolCallArgsText) return;\n    currentToolCallArgsText.argsText.close();\n    currentToolCallArgsText = undefined;\n  };\n\n  const transformer = new AssistantTransformStream<\n    TextStreamPart<Record<string, Tool>>\n  >({\n    transform(chunk, controller) {\n      const { type } = chunk;\n\n      if (\n        type !== \"tool-call-delta\" &&\n        type !== \"tool-call\" &&\n        type !== \"error\" &&\n        (type as string) !== \"tool-result\"\n      ) {\n        endCurrentToolCallArgsText();\n      }\n\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          controller.appendText(textDelta);\n          break;\n        }\n        case \"reasoning\": {\n          const { textDelta } = chunk;\n          controller.appendReasoning(textDelta);\n          break;\n        }\n        case \"tool-call-streaming-start\": {\n          const { toolCallId, toolName } = chunk;\n          currentToolCallArgsText = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolControllers.set(toolCallId, currentToolCallArgsText);\n          break;\n        }\n        case \"tool-call-delta\": {\n          const { toolCallId, argsTextDelta } = chunk;\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.argsText.append(argsTextDelta);\n          break;\n        }\n        case \"tool-result\" as string: {\n          const { toolCallId, result } = chunk as unknown as {\n            toolCallId: string;\n            result: ReadonlyJSONValue;\n          };\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.setResponse({\n            result,\n          });\n          toolController.close();\n          toolControllers.delete(toolCallId);\n          break;\n        }\n        case \"tool-call\": {\n          const { toolCallId, toolName, args } = chunk;\n          const toolController = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolController.argsText.append(JSON.stringify(args));\n          toolController.argsText.close();\n          toolControllers.set(toolCallId, toolController);\n          break;\n        }\n\n        case \"step-start\":\n          controller.enqueue({\n            type: \"step-start\",\n            path: [],\n            messageId: chunk.messageId,\n          });\n          break;\n        case \"step-finish\":\n          controller.enqueue({\n            type: \"step-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            isContinued: chunk.isContinued,\n          });\n          break;\n        case \"error\":\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n\n        case \"finish\": {\n          controller.enqueue({\n            type: \"message-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n          });\n          break;\n        }\n\n        case \"source\":\n          controller.appendSource({\n            type: \"source\",\n            ...chunk.source,\n          });\n          break;\n\n        case \"file\":\n          controller.appendFile({\n            type: \"file\",\n            mimeType: chunk.mimeType,\n            data: chunk.base64,\n          });\n          break;\n\n        case \"reasoning-signature\":\n        case \"redacted-reasoning\":\n          // ignore these for now\n          break;\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n    flush() {\n      for (const toolController of toolControllers.values()) {\n        toolController.close();\n      }\n      toolControllers.clear();\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n\nexport const fromStreamObject = (\n  stream: ReadableStream<ObjectStreamPart<unknown>>,\n  toolName: string,\n): AssistantStream => {\n  let toolCall!: ToolCallStreamController;\n  const transformer = new AssistantTransformStream<ObjectStreamPart<unknown>>({\n    start(controller) {\n      toolCall = controller.addToolCallPart(toolName);\n    },\n    transform(chunk, controller) {\n      const { type } = chunk;\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          toolCall.argsText.append(textDelta);\n          break;\n        }\n        case \"finish\": {\n          toolCall.argsText.close();\n          toolCall.setResponse({\n            result: \"{}\",\n          });\n          break;\n        }\n\n        case \"object\":\n          break;\n\n        case \"error\": {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n        }\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n","import type { LanguageModelV1StreamPart } from \"ai\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\n\nfunction bufferToBase64(buffer: Uint8Array) {\n  return btoa(String.fromCharCode(...buffer));\n}\n\nexport class LanguageModelV1StreamDecoder extends AssistantTransformStream<LanguageModelV1StreamPart> {\n  constructor() {\n    let currentToolCall:\n      | { toolCallId: string; controller: ToolCallStreamController }\n      | undefined;\n\n    const endCurrentToolCall = () => {\n      if (!currentToolCall) return;\n      currentToolCall.controller.argsText.close();\n      currentToolCall.controller.close();\n      currentToolCall = undefined;\n    };\n\n    super({\n      transform(chunk, controller) {\n        const { type } = chunk;\n        if (\n          type === \"text-delta\" ||\n          type === \"reasoning\" ||\n          type === \"tool-call\"\n        ) {\n          endCurrentToolCall();\n        }\n\n        switch (type) {\n          case \"text-delta\": {\n            controller.appendText(chunk.textDelta);\n            break;\n          }\n          case \"reasoning\": {\n            controller.appendReasoning(chunk.textDelta);\n            break;\n          }\n\n          case \"source\": {\n            controller.appendSource({\n              type: \"source\",\n              ...chunk.source,\n            });\n            break;\n          }\n\n          case \"file\": {\n            controller.appendFile({\n              type: \"file\",\n              mimeType: chunk.mimeType,\n              data:\n                typeof chunk.data === \"string\"\n                  ? chunk.data\n                  : bufferToBase64(chunk.data),\n            });\n            break;\n          }\n\n          case \"tool-call-delta\": {\n            const { toolCallId, toolName, argsTextDelta } = chunk;\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            } else {\n              endCurrentToolCall();\n              currentToolCall = {\n                toolCallId,\n                controller: controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                }),\n              };\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            }\n\n            break;\n          }\n\n          case \"tool-call\": {\n            const { toolCallId, toolName, args } = chunk;\n\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.close();\n            } else {\n              const toolController = controller.addToolCallPart({\n                toolCallId,\n                toolName,\n                argsText: args,\n              });\n              toolController.close();\n            }\n            \n            break;\n          }\n          case \"finish\": {\n            controller.enqueue({\n              type: \"message-finish\",\n              finishReason: chunk.finishReason,\n              usage: chunk.usage,\n              path: [],\n            });\n            controller.close();\n            break;\n          }\n\n          case \"error\":\n          case \"response-metadata\":\n          case \"reasoning-signature\":\n          case \"redacted-reasoning\":\n            break;\n\n          default: {\n            const unhandledType: never = type;\n            throw new Error(`Unhandled chunk type: ${unhandledType}`);\n          }\n        }\n      },\n      flush() {\n        endCurrentToolCall();\n      },\n    });\n  }\n}\n"],"mappings":"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","names":[]}