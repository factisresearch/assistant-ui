{"version":3,"sources":["../../../../src/runtimes/edge/streams/toolResultStream.ts"],"sourcesContent":["import { Tool } from \"../../../model-context/ModelContextTypes\";\nimport { LanguageModelV1StreamPart } from \"@ai-sdk/provider\";\nimport { z } from \"zod\";\nimport sjson from \"secure-json-parse\";\nimport { ReadonlyJSONValue } from \"../../../utils/json/json-value\";\n\nexport type ToolResultStreamPart =\n  | LanguageModelV1StreamPart\n  | {\n      type: \"annotations\";\n      annotations: ReadonlyJSONValue[];\n    }\n  | {\n      type: \"data\";\n      data: ReadonlyJSONValue[];\n    }\n  | {\n      type: \"source\";\n      source: {\n        readonly sourceType: \"url\";\n        readonly id: string;\n        readonly url: string;\n        readonly title?: string;\n      };\n    }\n  | {\n      type: \"tool-result\";\n      toolCallType: \"function\";\n      toolCallId: string;\n      toolName: string;\n      result: unknown;\n      isError?: boolean;\n    }\n  | {\n      type: \"step-finish\";\n      finishReason:\n        | \"stop\"\n        | \"length\"\n        | \"content-filter\"\n        | \"tool-calls\"\n        | \"error\"\n        | \"other\"\n        | \"unknown\";\n      usage: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n      isContinued: boolean;\n    };\n\nexport function toolResultStream(\n  tools: Record<string, Tool<any, any>> | undefined,\n  abortSignal: AbortSignal,\n) {\n  const toolCallExecutions = new Map<string, Promise<any>>();\n\n  return new TransformStream<ToolResultStreamPart, ToolResultStreamPart>({\n    transform(chunk, controller) {\n      // forward everything\n      controller.enqueue(chunk);\n\n      // handle tool calls\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"tool-call\": {\n          const { toolCallId, toolCallType, toolName, args: argsText } = chunk;\n          const tool = tools?.[toolName];\n          if (!tool || !tool.execute) return;\n\n          let args;\n          try {\n            args = sjson.parse(argsText);\n          } catch (e) {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallType,\n              toolCallId,\n              toolName,\n              result:\n                \"Function parameter parsing failed. \" +\n                JSON.stringify((e as Error).message),\n              isError: true,\n            });\n            return;\n          }\n\n          toolCallExecutions.set(\n            toolCallId,\n            (async () => {\n              if (!tool.execute) return;\n\n              let executeFn = tool.execute;\n\n              if (tool.parameters instanceof z.ZodType) {\n                const result = tool.parameters.safeParse(args);\n                if (!result.success) {\n                  executeFn =\n                    tool.experimental_onSchemaValidationError ??\n                    (() => {\n                      throw (\n                        \"Function parameter validation failed. \" +\n                        JSON.stringify(result.error.issues)\n                      );\n                    });\n                }\n              }\n\n              try {\n                const result = await executeFn(args, {\n                  toolCallId,\n                  abortSignal,\n                });\n\n                controller.enqueue({\n                  type: \"tool-result\",\n                  toolCallType,\n                  toolCallId,\n                  toolName,\n                  result: result === undefined ? \"<no result>\" : result,\n                });\n              } catch (error) {\n                controller.enqueue({\n                  type: \"tool-result\",\n                  toolCallType,\n                  toolCallId,\n                  toolName,\n                  result: \"Error: \" + error,\n                  isError: true,\n                });\n              } finally {\n                toolCallExecutions.delete(toolCallId);\n              }\n            })(),\n          );\n          break;\n        }\n\n        // ignore other parts\n        case \"text-delta\":\n        case \"reasoning\":\n        case \"source\":\n        case \"tool-call-delta\":\n        case \"tool-result\":\n        case \"step-finish\":\n        case \"finish\":\n        case \"error\":\n        case \"response-metadata\":\n        case \"annotations\":\n        case \"data\":\n          break;\n\n        default: {\n          const unhandledType: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n\n    async flush() {\n      await Promise.all(toolCallExecutions.values());\n    },\n  });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,iBAAkB;AAClB,+BAAkB;AA+CX,SAAS,iBACd,OACA,aACA;AACA,QAAM,qBAAqB,oBAAI,IAA0B;AAEzD,SAAO,IAAI,gBAA4D;AAAA,IACrE,UAAU,OAAO,YAAY;AAE3B,iBAAW,QAAQ,KAAK;AAGxB,YAAM,YAAY,MAAM;AACxB,cAAQ,WAAW;AAAA,QACjB,KAAK,aAAa;AAChB,gBAAM,EAAE,YAAY,cAAc,UAAU,MAAM,SAAS,IAAI;AAC/D,gBAAM,OAAO,QAAQ,QAAQ;AAC7B,cAAI,CAAC,QAAQ,CAAC,KAAK,QAAS;AAE5B,cAAI;AACJ,cAAI;AACF,mBAAO,yBAAAA,QAAM,MAAM,QAAQ;AAAA,UAC7B,SAAS,GAAG;AACV,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACA,QACE,wCACA,KAAK,UAAW,EAAY,OAAO;AAAA,cACrC,SAAS;AAAA,YACX,CAAC;AACD;AAAA,UACF;AAEA,6BAAmB;AAAA,YACjB;AAAA,aACC,YAAY;AACX,kBAAI,CAAC,KAAK,QAAS;AAEnB,kBAAI,YAAY,KAAK;AAErB,kBAAI,KAAK,sBAAsB,aAAE,SAAS;AACxC,sBAAM,SAAS,KAAK,WAAW,UAAU,IAAI;AAC7C,oBAAI,CAAC,OAAO,SAAS;AACnB,8BACE,KAAK,yCACJ,MAAM;AACL,0BACE,2CACA,KAAK,UAAU,OAAO,MAAM,MAAM;AAAA,kBAEtC;AAAA,gBACJ;AAAA,cACF;AAEA,kBAAI;AACF,sBAAM,SAAS,MAAM,UAAU,MAAM;AAAA,kBACnC;AAAA,kBACA;AAAA,gBACF,CAAC;AAED,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,QAAQ,WAAW,SAAY,gBAAgB;AAAA,gBACjD,CAAC;AAAA,cACH,SAAS,OAAO;AACd,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,QAAQ,YAAY;AAAA,kBACpB,SAAS;AAAA,gBACX,CAAC;AAAA,cACH,UAAE;AACA,mCAAmB,OAAO,UAAU;AAAA,cACtC;AAAA,YACF,GAAG;AAAA,UACL;AACA;AAAA,QACF;AAAA;AAAA,QAGA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACH;AAAA,QAEF,SAAS;AACP,gBAAM,gBAAuB;AAC7B,gBAAM,IAAI,MAAM,yBAAyB,aAAa,EAAE;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AAAA,IAEA,MAAM,QAAQ;AACZ,YAAM,QAAQ,IAAI,mBAAmB,OAAO,CAAC;AAAA,IAC/C;AAAA,EACF,CAAC;AACH;","names":["sjson"]}